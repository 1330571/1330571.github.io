<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"1330571.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="用Ocaml编写的树数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="Ocaml Tree,  An Intuitive Tutorial">
<meta property="og:url" content="http://1330571.github.io/posts/4080/index.html">
<meta property="og:site_name" content="BaiLan Life">
<meta property="og:description" content="用Ocaml编写的树数据结构">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210104215359261.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210104221045493.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210105004203912.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210105004251316.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210105004503695.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210107195155968.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210107195704276.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210108194827058.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210108195004831.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210108195751154.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210108201735637.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210108202110208.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210108202315145.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210108203207681.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210108203346920.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210108185953543.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210108184007479.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210108184234026.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210108185746717.png">
<meta property="og:image" content="http://1330571.github.io/posts/4080/image-20210108214635693.png">
<meta property="article:published_time" content="2021-01-07T09:32:33.000Z">
<meta property="article:modified_time" content="2022-11-23T11:11:40.057Z">
<meta property="article:author" content="YuSheng Xu">
<meta property="article:tag" content="ocaml">
<meta property="article:tag" content="data structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://1330571.github.io/posts/4080/image-20210104215359261.png">

<link rel="canonical" href="http://1330571.github.io/posts/4080/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Ocaml Tree,  An Intuitive Tutorial | BaiLan Life</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">BaiLan Life</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://1330571.github.io/posts/4080/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YuSheng Xu">
      <meta itemprop="description" content="Study & Work & Life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiLan Life">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Ocaml Tree,  An Intuitive Tutorial
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-07 17:32:33" itemprop="dateCreated datePublished" datetime="2021-01-07T17:32:33+08:00">2021-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-23 19:11:40" itemprop="dateModified" datetime="2022-11-23T19:11:40+08:00">2022-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ocaml/" itemprop="url" rel="index"><span itemprop="name">ocaml</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>25 mins.</span>
            </span>
            <div class="post-description">用Ocaml编写的树数据结构</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Ocaml-Tree-An-Intuitive-Tutorial"><a href="#Ocaml-Tree-An-Intuitive-Tutorial" class="headerlink" title="Ocaml Tree, An Intuitive Tutorial"></a>Ocaml Tree, An Intuitive Tutorial</h1><p>该文章主要描述了一些简单的树型数据结构。</p>
<h2 id="基本树"><a href="#基本树" class="headerlink" title="基本树"></a>基本树</h2><p>树形结构是一种非线性数据结构，在计算机科学领域有非常多的用途，一棵树由<strong>根</strong>和<strong>孩子</strong>组成，树是递归定义的，我们可以将树定义为一个<strong>type</strong>，他可以是空结点，也可以是一个非空结点，非空结点会有左、右两颗子树和值，我们可以将树定义为这样的结构。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="symbol">&#x27;a</span> tree = <span class="type">Empty</span> | <span class="type">Node</span> <span class="keyword">of</span> <span class="symbol">&#x27;a</span> * <span class="symbol">&#x27;a</span> tree * <span class="symbol">&#x27;a</span> tree</span><br></pre></td></tr></table></figure>

<p>如构造一颗这样的树，我们就可以采用这样的方式。</p>
<img src="/posts/4080/image-20210104215359261.png" alt="image-20210104215359261" style="zoom:50%;">

<p>该树的变量声明</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = <span class="type">Node</span>(<span class="number">1</span>, <span class="type">Node</span>(<span class="number">5</span>, <span class="type">Node</span>(<span class="number">4</span>, <span class="type">Empty</span>, <span class="type">Empty</span>),<span class="type">Node</span> (<span class="number">2</span>, <span class="type">Empty</span>, <span class="type">Empty</span>)), <span class="type">Node</span>(<span class="number">3</span>, <span class="type">Node</span>(<span class="number">10</span>,<span class="type">Empty</span>,<span class="type">Node</span>(<span class="number">17</span>,<span class="type">Empty</span>,<span class="type">Empty</span>)), <span class="type">Node</span>(<span class="number">14</span>,<span class="type">Empty</span>,<span class="type">Empty</span>)));;</span><br></pre></td></tr></table></figure>

<p>获取树的大小函数</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> size = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="number">0</span></span><br><span class="line">  | <span class="type">Node</span>(_, left, right) -&gt; <span class="number">1</span> + size left + size right;;</span><br></pre></td></tr></table></figure>

<p>先序、中序、后序遍历函数</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> preOrder = <span class="keyword">function</span></span><br><span class="line">| <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">| <span class="type">Node</span>(v,l,r) -&gt; <span class="type">Printf</span>.printf<span class="string">&quot;%d &quot;</span>  v ; preOrder(l) ; preOrder(r);;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> midOrder = <span class="keyword">function</span></span><br><span class="line">| <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">| <span class="type">Node</span>(v,l,r) -&gt; midOrder(l) ; <span class="type">Printf</span>.printf<span class="string">&quot;%d &quot;</span>  v ; midOrder(r);;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> postOrder = <span class="keyword">function</span></span><br><span class="line">| <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">| <span class="type">Node</span>(v,l,r) -&gt; postOrder(l) ; postOrder(r); <span class="type">Printf</span>.printf<span class="string">&quot;%d &quot;</span>  v ;;</span><br></pre></td></tr></table></figure>

<p>测试上述基本函数</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Printf</span>.printf <span class="string">&quot;树的大小为%d\n&quot;</span>  (size(node));</span><br><span class="line">printf <span class="string">&quot;先序遍历\n&quot;</span>;</span><br><span class="line">preOrder node;</span><br><span class="line">printf <span class="string">&quot;\n中序遍历\n&quot;</span>;</span><br><span class="line">midOrder node;</span><br><span class="line">printf <span class="string">&quot;\n后序遍历\n&quot;</span>;</span><br><span class="line">postOrder node;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">树的大小为8</span><br><span class="line">先序遍历</span><br><span class="line">1 5 4 2 3 10 17 14</span><br><span class="line">中序遍历</span><br><span class="line">4 5 2 1 10 17 3 14</span><br><span class="line">后序遍历</span><br><span class="line">4 2 5 17 10 14 3 1</span><br></pre></td></tr></table></figure>

<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>在有了基本的树结构之后，我们考虑构建二叉查找树，二叉查找树在插入结点时，将比当前结点大的结点插到右子树，否则插入到左子树，如果按照 3-1-5-2-4-17-14-10 的顺序插入，会构建如下的二叉查找树。</p>
<img src="/posts/4080/image-20210104221045493.png" alt="image-20210104221045493" style="zoom:50%;">

<p>为了构建这样一颗二叉树，同时加上纯函数式的限制，我们每次插入结点时都会建造一颗新的二叉树。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> insert tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="type">Node</span> (<span class="keyword">value</span>, <span class="type">Empty</span>, <span class="type">Empty</span>)</span><br><span class="line">  | <span class="type">Node</span> (v, left, right) -&gt;</span><br><span class="line">      <span class="keyword">if</span> v = <span class="keyword">value</span> <span class="keyword">then</span> tree</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">value</span> &gt; v <span class="keyword">then</span> <span class="type">Node</span> (v, insert left <span class="keyword">value</span>, right)</span><br><span class="line">      <span class="keyword">else</span> <span class="type">Node</span> (v, left, insert right <span class="keyword">value</span>)</span><br></pre></td></tr></table></figure>

<p>函数解释</p>
<ul>
<li><p>该函数是二叉排序树的插入函数，插入数值已存在时不产生任何动作，直接返回该结点</p>
</li>
<li><p>插入数值小于当前结点 当前数值不变，右子树不变，那么就需要把这个值插入到左子树</p>
</li>
<li><p>插入数值大于当前结点 当前数字不变，左子树不变，那么就需要把这个值插入到右子树</p>
</li>
<li><p>如果碰到了空结点，那么就代表寻找到了合适的插入位置，将其插入并且返回 Node</p>
</li>
</ul>
<p>函数测试</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(* 3-1-5-2-4-17-14-10 *)</span></span><br><span class="line"><span class="keyword">let</span> node = insert <span class="type">Empty</span> <span class="number">3</span>;;</span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">1</span>;;</span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">5</span>;;</span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">2</span>;;</span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">4</span>;;</span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">17</span>;;</span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">14</span>;;</span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">10</span>;;</span><br><span class="line"></span><br><span class="line">printf <span class="string">&quot;\n二叉排序树中序遍历\n&quot;</span>;</span><br><span class="line">midOrder node;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二叉排序树中序遍历</span><br><span class="line">1 2 3 4 5 10 14 17</span><br></pre></td></tr></table></figure>

<p>结构验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">utop <span class="comment"># node;;</span></span><br><span class="line">- : int tree =</span><br><span class="line">Node (3, Node (1, Empty, Node (2, Empty, Empty)),</span><br><span class="line"> Node (5, Node (4, Empty, Empty),</span><br><span class="line">  Node (17, Node (14, Node (10, Empty, Empty), Empty), Empty)))</span><br></pre></td></tr></table></figure>

<p>对于二叉树排序树，有用的不仅仅是插入，还有查询和删除</p>
<p>查询函数</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> query tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">false</span></span><br><span class="line">  | <span class="type">Node</span>(v,l,r) -&gt; v = <span class="keyword">value</span> || query l <span class="keyword">value</span> || query r <span class="keyword">value</span> ;;</span><br></pre></td></tr></table></figure>

<p>验证正确性</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> printBool = <span class="keyword">function</span></span><br><span class="line">| <span class="literal">true</span> -&gt; printf<span class="string">&quot;结果为真\n&quot;</span>;</span><br><span class="line">| <span class="literal">false</span> -&gt; printf<span class="string">&quot;结果为假\n&quot;</span>;;</span><br><span class="line"></span><br><span class="line">print_endline(<span class="string">&quot;&quot;</span>);</span><br><span class="line">printBool (query node <span class="number">10</span>); <span class="comment">(* should be true *)</span></span><br><span class="line">printBool (query node <span class="number">11</span>); <span class="comment">(* should be false *)</span></span><br></pre></td></tr></table></figure>

<p>删除函数</p>
<p>对于二叉排序树的删除，我们分三种情况</p>
<ol>
<li>叶子结点，直接删除即可</li>
<li>只有单一的孩子，将这个孩子结点与其父结点相连</li>
<li>有左右孩子，寻找左子树最大结点$r$，覆盖该结点，此时删除直接完成</li>
</ol>
<p>对应图例</p>
<ul>
<li><p>情况 1，删除结点 2，2 直接移除连线</p>
<img src="/posts/4080/image-20210105004203912.png" alt="image-20210105004203912" style="zoom:33%;">
</li>
<li><p>情况 2 删除结点 14，10 与 17 直接相连</p>
<img src="/posts/4080/image-20210105004251316.png" alt="image-20210105004251316" style="zoom:33%;">
</li>
<li><p>情况 3 删除结点 3，2 替换 3 的位置</p>
<img src="/posts/4080/image-20210105004503695.png" alt="image-20210105004503695" style="zoom:33%;"></li>
</ul>
<p>综上所述，我们可以得出下述的算法</p>
<ol>
<li>如果该结点是叶子结点，直接返回<strong>Empty</strong>，删除完毕。</li>
<li>如果该结点是单孩子结点，直接返回他的<strong>孩子结点</strong>。</li>
<li>如果该结点有左右子树，把最左子树的最右子树替换到被删除结点，同时被删除结点的上一个结点的右子树修改为空，对于函数式语言来说，显然我们要做的是两步骤，在被删除结点修改当前值$v$，以及最左子树的最右子树，返回一个<strong>Empty</strong>和一个$v’$，所以我们这边需要一个新的函数去寻找左子树的最右子树</li>
</ol>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(* 删除二叉排序树 *)</span></span><br><span class="line"><span class="comment">(* Thanks for the reference https://codereview.stackexchange.com/questions/187716/deleting-a-node-from-binary-tree-in-ocaml *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> mostRight = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; failwith <span class="string">&quot;结点存在一些问题&quot;</span></span><br><span class="line">  | <span class="type">Node</span> (v, _, <span class="type">Empty</span>) -&gt; v</span><br><span class="line">  | <span class="type">Node</span> (_, _, r) -&gt; mostRight r</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> delete tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="type">Empty</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) <span class="keyword">when</span> v &lt; <span class="keyword">value</span> -&gt; <span class="type">Node</span> (v, l, delete r <span class="keyword">value</span>)</span><br><span class="line">  | <span class="type">Node</span> (v, l, r) <span class="keyword">when</span> v &gt; <span class="keyword">value</span> -&gt; <span class="type">Node</span> (v, delete l <span class="keyword">value</span>, r)</span><br><span class="line">  | <span class="type">Node</span> (v, <span class="type">Empty</span>, <span class="type">Empty</span>) -&gt; <span class="type">Empty</span> <span class="comment">(* 直接删除自己 对应情况1 *)</span></span><br><span class="line">  | <span class="type">Node</span> (v, <span class="type">Empty</span>, r) -&gt; r <span class="comment">(* 情况2 删除自己 连接右子树 *)</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, <span class="type">Empty</span>) -&gt; l <span class="comment">(* 情况2 删除自己 连接左子树 *)</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) -&gt; <span class="comment">(* 情况3，替换自己，删除原来的值 *)</span></span><br><span class="line">      <span class="keyword">let</span> newValue = mostRight l <span class="keyword">in</span></span><br><span class="line">      <span class="type">Node</span> (newValue, delete l newValue, r)</span><br></pre></td></tr></table></figure>

<p>以及对应的测试</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(* 测试删除 *)</span></span><br><span class="line"><span class="keyword">let</span> delete2 = delete node <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> delete14 = delete node <span class="number">14</span></span><br><span class="line"><span class="keyword">let</span> delete3 = delete node <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val delete : &#x27;a tree -&gt; &#x27;a -&gt; &#x27;a tree = &lt;fun&gt;</span><br><span class="line">val delete2 : int tree =</span><br><span class="line">  Node (3, Node (1, Empty, Empty),</span><br><span class="line">   Node (5, Node (4, Empty, Empty),</span><br><span class="line">    Node (17, Node (14, Node (10, Empty, Empty), Empty), Empty)))</span><br><span class="line">val delete14 : int tree =</span><br><span class="line">  Node (3, Node (1, Empty, Node (2, Empty, Empty)),</span><br><span class="line">   Node (5, Node (4, Empty, Empty),</span><br><span class="line">    Node (17, Node (10, Empty, Empty), Empty)))</span><br><span class="line">val delete3 : int tree =</span><br><span class="line">  Node (2, Node (1, Empty, Empty),</span><br><span class="line">   Node (5, Node (4, Empty, Empty),</span><br><span class="line">    Node (17, Node (14, Node (10, Empty, Empty), Empty), Empty)))</span><br></pre></td></tr></table></figure>

<p>可以看见确实成功的变成了我们图示的样子。</p>
<h2 id="自平衡二叉树"><a href="#自平衡二叉树" class="headerlink" title="自平衡二叉树"></a>自平衡二叉树</h2><p>在一棵高度平衡的二叉排序树中，我们几乎可以以$\log n$的时间开销去寻找元素，但是考虑特殊构造的数据$1,2,3..n$，就会让二叉排序树退化成一个线性链表，这显然是我们无法接受的，我们给结点定义一个<strong>平衡因子</strong>，表示左右子树的深度之差， 一般将其分为四种情况考虑，用$L$表示左子树不平衡，$R$表示右子树不平衡，一共有四种情况。</p>
<p>请注意这些序号并不表示数据本身的大小，只是一个逻辑关系。</p>
<h3 id="RR-数字不代表数值关系"><a href="#RR-数字不代表数值关系" class="headerlink" title="RR(数字不代表数值关系)"></a>RR(数字不代表数值关系)</h3><img src="/posts/4080/image-20210107195155968.png" alt="image-20210107195155968" style="zoom:50%;">

<p>这样的树我们可以我们可以在子树<strong>3</strong>处做一次左旋操作，使得树变成平衡状态，具体操作是<strong>1</strong>旋转下去，同时原先<strong>4</strong>的位置被<strong>1</strong>接管，那么显然<strong>3</strong>的原左子树将成为<strong>1</strong>的右子树，这样完成了一次左旋操作，如果你不能理解这个过程，请务必亲手尝试一下，并结合下面的代码阅读，所谓左旋也并非只是向左旋转，请不要将重心过度放在左旋这个动作本身的语义上。</p>
<img src="/posts/4080/image-20210107195704276.png" alt="image-20210107195704276" style="zoom:50%;">

<h3 id="LL-数字不代表数值关系"><a href="#LL-数字不代表数值关系" class="headerlink" title="LL(数字不代表数值关系)"></a>LL(数字不代表数值关系)</h3><img src="/posts/4080/image-20210108194827058.png" alt="image-20210108194827058" style="zoom:50%;">

<p>这种情况和<strong>RR</strong>型真好相反，我们对<strong>2</strong>做一次右旋操作就可以达成目的，具体可以查看旋转后的图片自行想象。</p>
<img src="/posts/4080/image-20210108195004831.png" alt="image-20210108195004831" style="zoom:50%;">

<h3 id="RL-数字不代表数值关系"><a href="#RL-数字不代表数值关系" class="headerlink" title="RL(数字不代表数值关系)"></a>RL(数字不代表数值关系)</h3><img src="/posts/4080/image-20210108195751154.png" alt="image-20210108195751154" style="zoom:50%;">

<p>这种情况通过一次<strong>L</strong>旋转或者<strong>R</strong>旋转都无法使得二叉树平衡，对应的，我们需要进行一次<strong>右旋</strong>再进行一次<strong>左旋</strong>，具体的流程图如下</p>
<p>首先进行一次<strong>右旋</strong>，注意目标是失去平衡结点的右子树。</p>
<img src="/posts/4080/image-20210108201735637.png" alt="image-20210108201735637" style="zoom:50%;">

<p>然后此时变成了<strong>RR</strong>型结点，在进行一次<strong>左旋</strong>。</p>
<img src="/posts/4080/image-20210108202110208.png" alt="image-20210108202110208" style="zoom:50%;">

<h3 id="LR-数字代表数值关系"><a href="#LR-数字代表数值关系" class="headerlink" title="LR(数字代表数值关系)"></a>LR(数字代表数值关系)</h3><p>此次采用了真实数据，数据大小即代表真实的结点情况</p>
<img src="/posts/4080/image-20210108202315145.png" alt="image-20210108202315145" style="zoom:50%;">

<p>首先进行<strong>左旋</strong></p>
<img src="/posts/4080/image-20210108203207681.png" alt="image-20210108203207681" style="zoom:50%;">

<p>再进行一次<strong>右旋</strong></p>
<img src="/posts/4080/image-20210108203346920.png" alt="image-20210108203346920" style="zoom:50%;">

<p>对于这种数据结构，我们的核心就是两种操作，左旋、右旋。</p>
<p>这边是一年前的数据结构课设的 C 语言 AVL 树代码，通过下面的代码，希望能够给你一个更加直观地、大致上的我们印象，让你要知道如何操作 AVL 树来使它达成平衡的目的。</p>
<h3 id="左右旋"><a href="#左右旋" class="headerlink" title="左右旋"></a>左右旋</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">node *<span class="title function_">rightRotation</span><span class="params">(node *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//右旋 left提到root位置，root下去，同时root接管left的右儿子（root左儿子）</span></span><br><span class="line">    node *tmp = root-&gt;leftSon;</span><br><span class="line">    root-&gt;leftSon = tmp-&gt;rightSon;</span><br><span class="line">    tmp-&gt;rightSon = root;</span><br><span class="line">    getTreeHeight(tmp);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node *<span class="title function_">leftRotation</span><span class="params">(node *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//左旋 right提到root位置，root下去，root接管left的左儿子 （root右儿子）</span></span><br><span class="line">    node *tmp = root-&gt;rightSon;</span><br><span class="line">    root-&gt;rightSon = tmp-&gt;leftSon;</span><br><span class="line">    tmp-&gt;leftSon = root;</span><br><span class="line">    getTreeHeight(tmp); <span class="comment">//新跟节点重新判深度</span></span><br><span class="line">    <span class="keyword">return</span> tmp;         <span class="comment">//新结点 是否要用于下一步旋转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###二叉树的重新平衡</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">node *<span class="title function_">rebalance</span><span class="params">(node *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> balance = getTreeBalance(root);</span><br><span class="line">    <span class="comment">// printf(&quot;balance = %d\n&quot;, balance);</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//L? 操作</span></span><br><span class="line">        <span class="keyword">if</span> (getTreeBalance(root-&gt;leftSon) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//LL 对应左子树更多</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;LL\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> rightRotation(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//LR 对应右子树更多</span></span><br><span class="line">            <span class="comment">//下级L 这级R</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;LR\n&quot;</span>);</span><br><span class="line">            root-&gt;leftSon = leftRotation(root-&gt;leftSon);</span><br><span class="line">            <span class="keyword">return</span> rightRotation(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//R? 操作</span></span><br><span class="line">        <span class="keyword">if</span> (getTreeBalance(root-&gt;rightSon) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//RR 对应右子树更多</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;RR\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> leftRotation(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//RL</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;RL\n&quot;</span>);</span><br><span class="line">            root-&gt;rightSon = rightRotation(root-&gt;rightSon);</span><br><span class="line">            <span class="keyword">return</span> leftRotation(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写二叉树辅助输出函数"><a href="#编写二叉树辅助输出函数" class="headerlink" title="编写二叉树辅助输出函数"></a>编写二叉树辅助输出函数</h3><p>一个求幂的函数</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> pow base power = <span class="keyword">if</span> power = <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> base * pow base (power - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>对应函数的尾递归版本，尾递归版本拥有更快的速度和更少的内存占用，非常值得提倡</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pow_tr base power =</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> _pow_tr base power sum =</span><br><span class="line">    <span class="keyword">if</span> power = <span class="number">0</span> <span class="keyword">then</span> sum <span class="keyword">else</span> _pow_tr base (power - <span class="number">1</span>) (base * sum) <span class="keyword">in</span></span><br><span class="line">  _pow_tr base power <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>访问<a target="_blank" rel="noopener" href="https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/data/tail_recursion.html">Link</a>学习更多有关尾递归的知识</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>首先需要一个新的构造子，之前的构造子并不包含有关深度的信息，对于自平衡二叉树来说，我们还需要关注到他树的深度。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="symbol">&#x27;a</span> avlTree = <span class="type">Empty</span> | <span class="type">Node</span> <span class="keyword">of</span> <span class="symbol">&#x27;a</span> * <span class="symbol">&#x27;a</span> avlTree * <span class="symbol">&#x27;a</span> avlTree * <span class="built_in">int</span></span><br></pre></td></tr></table></figure>

<h4 id="左旋和右旋"><a href="#左旋和右旋" class="headerlink" title="左旋和右旋"></a>左旋和右旋</h4><p>我们在 Ocaml 中能够使用一种更加优雅的方式去处理，模式匹配可以直接把我们需要的两个受到影响的点取出来建造新的结点，代码会变得异常的短。<br><strong>左旋</strong>就是重新生成了一个结点，将该结点的数值变成了右子树的数值，将左子树变为了一个新建的结点，这个过程和前面的描述是一样的，该步骤完成之后整一个旋转过程就直接完成了，剩余的东西我们无需再去管理，和<strong>C 语言</strong>版本对比，因为我们不需要去处理指针的指向，我们将所有的结点都视作 avlTree 的构造子类型，就可以通过不断构造去新建受影响的结点，不需要向 C 语言一样去修改不同点之间的逻辑关系。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(* 辅助生成结点的函数 因为要动态控制树的高度 *)</span></span><br><span class="line"><span class="keyword">let</span> makeNode <span class="keyword">value</span> leftTree rightTree =</span><br><span class="line">  <span class="type">Node</span></span><br><span class="line">    ( <span class="keyword">value</span></span><br><span class="line">    , leftTree</span><br><span class="line">    , rightTree</span><br><span class="line">    , <span class="number">1</span> + max (avlHeight leftTree) (avlHeight rightTree) )</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> avlHeight = <span class="keyword">function</span> <span class="type">Empty</span> -&gt; <span class="number">0</span> | <span class="type">Node</span> (_, _, _, h) -&gt; h</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 左旋 *)</span></span><br><span class="line"><span class="keyword">let</span> rotateLeft = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, <span class="type">Node</span> (_v, _l, _r, _), _) -&gt; makeNode _v (makeNode v l _l) _r</span><br><span class="line">  | _ -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* 右旋 *)</span></span><br><span class="line"><span class="keyword">let</span> rotateRight = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Node</span> (v, <span class="type">Node</span> (_v, _l, _r, _), r, _) -&gt; makeNode _v _l (makeNode v _r r)</span><br><span class="line">  | _ -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="LR-情况判断-以及-左右旋转"><a href="#LR-情况判断-以及-左右旋转" class="headerlink" title="LR 情况判断 以及 左右旋转"></a>LR 情况判断 以及 左右旋转</h4><p>我们利用之前的函数就可以完成 LR 情况的判断，具体的判断流程是如果该结点为<strong>Empty</strong>结点，我们可以直接插入该结点，否则的话就需要递归插入这个结点，根据插入之后的情况来判断是否需要左右旋转，</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> insert tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="type">Node</span> (<span class="keyword">value</span>, <span class="type">Empty</span>, <span class="type">Empty</span>, <span class="number">1</span>)</span><br><span class="line">  | <span class="type">Node</span> (v, l, r, _) -&gt; (</span><br><span class="line">      <span class="keyword">if</span> v = <span class="keyword">value</span> <span class="keyword">then</span> tree</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">value</span> &lt; v <span class="keyword">then</span></span><br><span class="line">        <span class="comment">(* 如何判断插入之后是否需要左右旋转  我们需要插入后的树的高度 *)</span></span><br><span class="line">        <span class="keyword">match</span> insert l <span class="keyword">value</span> <span class="keyword">with</span></span><br><span class="line">        | <span class="type">Empty</span> -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br><span class="line">        | <span class="type">Node</span> (_v, _l, _r, _h) <span class="keyword">as</span> _node -&gt;</span><br><span class="line">            <span class="keyword">if</span> _h - avlHeight r &lt;= <span class="number">1</span> <span class="keyword">then</span> makeNode v _node r</span><br><span class="line">              <span class="comment">(* 直接插入这个结点不需要旋转 *)</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">let</span> _node =</span><br><span class="line">                <span class="comment">(* 根据前面的描述判断是否需要多旋转一次 *)</span></span><br><span class="line">                <span class="keyword">if</span> avlHeight _l &lt; avlHeight _r <span class="keyword">then</span> rotateLeft _node <span class="keyword">else</span> _node</span><br><span class="line">              <span class="keyword">in</span></span><br><span class="line">              rotateRight (makeNode v _node r) <span class="comment">(* L? 情况通用的右旋 *)</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">match</span> insert r <span class="keyword">value</span> <span class="keyword">with</span></span><br><span class="line">        | <span class="type">Empty</span> -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br><span class="line">        | <span class="type">Node</span> (_v, _l, _r, _h) <span class="keyword">as</span> _node -&gt;</span><br><span class="line">            <span class="keyword">if</span> _h - avlHeight l &lt;= <span class="number">1</span> <span class="keyword">then</span> makeNode v l _node</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">let</span> _node =</span><br><span class="line">                <span class="keyword">if</span> avlHeight _l &gt; avlHeight _r <span class="keyword">then</span> rotateRight _node <span class="keyword">else</span> _node</span><br><span class="line">              <span class="keyword">in</span></span><br><span class="line">              rotateLeft (makeNode v l _node) )</span><br></pre></td></tr></table></figure>

<h3 id="插入测试"><a href="#插入测试" class="headerlink" title="插入测试"></a>插入测试</h3><p>####RR</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> avlNode = insert <span class="type">Empty</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">30</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">40</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val avlNode : int avlTree = Node (10, Empty, Empty, 1)</span><br><span class="line">val avlNode : int avlTree = Node (10, Empty, Node (20, Empty, Empty, 1), 2)</span><br><span class="line">val avlNode : int avlTree =</span><br><span class="line">  Node (20, Node (10, Empty, Empty, 1), Node (30, Empty, Empty, 1), 2)</span><br><span class="line">val avlNode : int avlTree =</span><br><span class="line">  Node (20, Node (10, Empty, Empty, 1),</span><br><span class="line">   Node (30, Empty, Node (40, Empty, Empty, 1), 2), 3)</span><br></pre></td></tr></table></figure>

<center>旋转过程</center>

<img src="/posts/4080/image-20210108185953543.png" alt="image-20210108185953543" style="zoom:50%;">

<img src="/posts/4080/image-20210108184007479.png" alt="image-20210108184007479" style="zoom:50%;">

<img src="/posts/4080/image-20210108184234026.png" alt="image-20210108184234026" style="zoom:50%;">

<img src="/posts/4080/image-20210108185746717.png" alt="image-20210108185746717" style="zoom:50%;">

<h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p>分别插入<code>40 30 20 10</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val avlNode : int avlTree = Node (40, Empty, Empty, 1)</span><br><span class="line">val avlNode : int avlTree = Node (40, Node (30, Empty, Empty, 1), Empty, 2)</span><br><span class="line">val avlNode : int avlTree =</span><br><span class="line">  Node (30, Node (20, Empty, Empty, 1), Node (40, Empty, Empty, 1), 2)</span><br><span class="line">val avlNode : int avlTree =</span><br><span class="line">  Node (30, Node (20, Node (10, Empty, Empty, 1), Empty, 2),</span><br><span class="line">   Node (40, Empty, Empty, 1), 3)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    30</span><br><span class="line">   /  \</span><br><span class="line">  20  40</span><br><span class="line"> /</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>验证正确</p>
<h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p>分别插入<code>30 10 20</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val avlNode : int avlTree = Node (30, Empty, Empty, 1)</span><br><span class="line">val avlNode : int avlTree = Node (30, Node (10, Empty, Empty, 1), Empty, 2)</span><br><span class="line">val avlNode : int avlTree = Node (20, Node (10, Empty, Empty, 1), Node (30, Empty, Empty, 1), 2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  20</span><br><span class="line"> /  \</span><br><span class="line">10  30</span><br></pre></td></tr></table></figure>

<p>验证正确</p>
<h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p>分别插入<code>10 30 20</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val avlNode : int avlTree = Node (10, Empty, Empty, 1)</span><br><span class="line">val avlNode : int avlTree = Node (10, Empty, Node (30, Empty, Empty, 1), 2)</span><br><span class="line">val avlNode : int avlTree = Node (20, Node (10, Empty, Empty, 1), Node (30, Empty, Empty, 1), 2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  20</span><br><span class="line"> /  \</span><br><span class="line">10  30</span><br></pre></td></tr></table></figure>

<p>验证正确</p>
<h4 id="插入较多的数字"><a href="#插入较多的数字" class="headerlink" title="插入较多的数字"></a>插入较多的数字</h4><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> avlNode = insert <span class="type">Empty</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">30</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">25</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">34</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">37</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">39</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">22</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">16</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">13</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">7</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val avlNode : int avlTree =</span><br><span class="line">  Node (20,</span><br><span class="line">   Node (13,</span><br><span class="line">    Node (7, Node (3, Empty, Empty, 1), Node (10, Empty, Empty, 1), 2),</span><br><span class="line">    Node (16, Empty, Empty, 1), 3),</span><br><span class="line">   Node (30, Node (25, Node (22, Empty, Empty, 1), Empty, 2),</span><br><span class="line">    Node (37, Node (34, Empty, Empty, 1), Node (39, Empty, Empty, 1), 2), 3),</span><br><span class="line">   4)</span><br></pre></td></tr></table></figure>

<p>结果图示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">         20</span><br><span class="line">     /--- ---\</span><br><span class="line">    13        30</span><br><span class="line">   /  \      /  \</span><br><span class="line">  7   16    25  37</span><br><span class="line"> / \       /   /  \</span><br><span class="line">3  10     22  34  39</span><br></pre></td></tr></table></figure>

<p>应该没有太多的问题</p>
<h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><p>删除结点的过程和 BST 删除类似，唯一的区别是删除完之后需要重新调整平衡，有可能删除完之后会造成树失去平衡，步骤和<strong>insert</strong>差不多，请自行思考，如果思考不了看 C 语言版本。</p>
<h4 id="排序数据输出-中序遍历"><a href="#排序数据输出-中序遍历" class="headerlink" title="排序数据输出(中序遍历)"></a>排序数据输出(中序遍历)</h4><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> avlMidOrder = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r, _) -&gt; avlMidOrder l ; printf <span class="string">&quot;%d &quot;</span> v ; avlMidOrder r</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 7 10 13 16 20 22 25 30 34 37 39</span><br></pre></td></tr></table></figure>

<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>哈夫曼树是哈夫曼编码的一种求解方式，我们可以利用这种数据结构给数据进行一种编码，原则就是出现次数多的字符使用更短的编码，次数少的字符使用更长的编码，可以采用堆这一个数据结构求解该编码，翻出去年的数据结构课设希望能够有一种直观的理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CoreType::node *<span class="title">getHuffmanTreeByCntArray</span><span class="params">(vector&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; &amp;frequencyArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> CoreType::node;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span> <span class="comment">//functor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> node *a, <span class="type">const</span> node *b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;weight &gt;= b-&gt;weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue&lt;node *, vector&lt;node *&gt;, cmp&gt; assistHeap;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [ch, cnt] : frequencyArray)</span><br><span class="line">    &#123;</span><br><span class="line">        node *tmpNode = <span class="keyword">new</span> node&#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, cnt, <span class="built_in">int</span>(ch)&#125;;</span><br><span class="line">        assistHeap.<span class="built_in">push</span>(tmpNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (assistHeap.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node *firstNode = assistHeap.<span class="built_in">top</span>();</span><br><span class="line">        assistHeap.<span class="built_in">pop</span>();</span><br><span class="line">        node *secondNode = assistHeap.<span class="built_in">top</span>();</span><br><span class="line">        assistHeap.<span class="built_in">pop</span>();</span><br><span class="line">        node *newNode = <span class="keyword">new</span> node&#123;firstNode, secondNode, firstNode-&gt;weight + secondNode-&gt;weight, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;Combine &quot; &lt;&lt; firstNode-&gt;weight &lt;&lt; &quot; With &quot; &lt;&lt; secondNode-&gt;weight &lt;&lt; endl;</span></span><br><span class="line">        assistHeap.<span class="built_in">push</span>(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assistHeap.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试给定哈夫曼树结点能否生成编码</strong></p>
<p>构造如图所示的哈夫曼树，下面表示应该的编码方式</p>
 <img src="/posts/4080/image-20210108214635693.png" alt="image-20210108214635693" style="zoom:50%;">

<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodell = <span class="type">HuffmanNode</span> &#123;data= <span class="type">Some</span> <span class="string">&#x27;a&#x27;</span>; count= <span class="number">0</span>; left= <span class="type">Empty</span>; right= <span class="type">Empty</span>&#125;</span><br><span class="line"><span class="keyword">let</span> nodelr = <span class="type">HuffmanNode</span> &#123;data= <span class="type">Some</span> <span class="string">&#x27;c&#x27;</span>; count= <span class="number">0</span>; left= <span class="type">Empty</span>; right= <span class="type">Empty</span>&#125;</span><br><span class="line"><span class="keyword">let</span> noderl = <span class="type">HuffmanNode</span> &#123;data= <span class="type">Some</span> <span class="string">&#x27;b&#x27;</span>; count= <span class="number">0</span>; left= <span class="type">Empty</span>; right= <span class="type">Empty</span>&#125;</span><br><span class="line"><span class="keyword">let</span> noderr = <span class="type">HuffmanNode</span> &#123;data= <span class="type">Some</span> <span class="string">&#x27;d&#x27;</span>; count= <span class="number">0</span>; left= <span class="type">Empty</span>; right= <span class="type">Empty</span>&#125;</span><br><span class="line"><span class="keyword">let</span> nodel = <span class="type">HuffmanNode</span> &#123;data= <span class="type">None</span>; count= <span class="number">0</span>; left= nodell; right= nodelr&#125;</span><br><span class="line"><span class="keyword">let</span> noder = <span class="type">HuffmanNode</span> &#123;data= <span class="type">None</span>; count= <span class="number">0</span>; left= noderl; right= noderr&#125;</span><br><span class="line"><span class="keyword">let</span> testNode = <span class="type">HuffmanNode</span> &#123;data= <span class="type">None</span>; count= <span class="number">0</span>; left= nodel; right= noder&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义哈夫曼树的数据结构"><a href="#定义哈夫曼树的数据结构" class="headerlink" title="定义哈夫曼树的数据结构"></a>定义哈夫曼树的数据结构</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> optional_char = <span class="type">Some</span> <span class="keyword">of</span> <span class="built_in">char</span> | <span class="type">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> huffmanTree = <span class="type">Empty</span> | <span class="type">HuffmanNode</span> <span class="keyword">of</span> huffmanNode</span><br><span class="line"><span class="keyword">and</span> huffmanNode =</span><br><span class="line">  &#123;data: optional_char * <span class="built_in">int</span>; count: <span class="built_in">int</span>; left: huffmanTree; right: huffmanTree&#125;</span><br></pre></td></tr></table></figure>

<p>我们的<strong>哈夫曼</strong>树也是一颗树，但他会额外拥有一个<code>count</code>属性来表明当前这个结点的计算次数，同时他的数据是<strong>可选</strong>类型，因为从上文的哈夫曼树例子我们可以看出，只有叶子结点会挂载数据。</p>
<p>我们实现哈夫曼的过程本质上就是优先队列上不断取出和合并的过程，因此我们需要再做一个优先队列，优先队列可以做成模块，通过函子(functor)去初始化模块，增加泛型开发的能力。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">type</span> <span class="type">Comparable</span> = <span class="keyword">sig</span></span><br><span class="line">  <span class="keyword">type</span> t</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> compare : t -&gt; t -&gt; <span class="built_in">int</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="type">Make_priority_queue</span> (<span class="type">QueueNode</span> : <span class="type">Comparable</span>) = <span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">let</span> top = <span class="keyword">function</span></span><br><span class="line">    | hd :: tl -&gt; hd</span><br><span class="line">    | <span class="literal">[]</span> -&gt; failwith <span class="string">&quot;没有更多结点了 Error on top&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pop = <span class="keyword">function</span></span><br><span class="line">    | hd :: tl -&gt; tl</span><br><span class="line">    | <span class="literal">[]</span> -&gt; failwith <span class="string">&quot;没有更多结点了 Error on pop&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> push queue <span class="keyword">value</span> =</span><br><span class="line">    <span class="keyword">match</span> queue <span class="keyword">with</span></span><br><span class="line">    | <span class="literal">[]</span> -&gt; [<span class="keyword">value</span>]</span><br><span class="line">    | hd :: tl -&gt;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">QueueNode</span>.compare <span class="keyword">value</span> hd &gt; <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">value</span> :: queue</span><br><span class="line">        <span class="keyword">else</span> hd :: push tl <span class="keyword">value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> size = <span class="keyword">function</span> _ :: tl -&gt; <span class="number">1</span> + size tl | <span class="literal">[]</span> -&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> empty = <span class="keyword">function</span> hd :: tl -&gt; <span class="literal">false</span> | <span class="literal">[]</span> -&gt; <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> newQueue : <span class="type">QueueNode</span>.t <span class="built_in">list</span> = <span class="literal">[]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>构造一个<strong>int</strong>类型的优先队列模块及测试</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="type">Int_priority_queue</span> = <span class="type">Make_priority_queue</span> (<span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">type</span> t = <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> compare a b = a - b</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push <span class="literal">[]</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> int_priority_queue_print_helper = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">()</span></span><br><span class="line">  | hd :: tl -&gt;</span><br><span class="line">      <span class="type">Printf</span>.printf <span class="string">&quot;%d &quot;</span> hd ;</span><br><span class="line">      int_priority_queue_print_helper tl</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">printf <span class="string">&quot;\n&quot;</span></span><br><span class="line">;;</span><br><span class="line">int_priority_queue_print_helper priority_queue</span><br><span class="line">;;</span><br><span class="line">printf <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- : unit = ()</span><br><span class="line">5 4 3 2 1 - : unit = ()</span><br></pre></td></tr></table></figure>

<p>非常成功，因此我们现在可以直接考虑哈夫曼树所需要用的额外函数。</p>
<p><strong>合并两棵树</strong></p>
<p>注意合并操作之后我们要把 data 字段变为空，否则我们将无法区别叶子结点和非叶子结点</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> huffmanMergeTwoTree leftTree rightTree : huffmanNode =</span><br><span class="line">  &#123; data= (<span class="type">None</span>, leftTree.count + rightTree.count)</span><br><span class="line">  ; count= leftTree.count + rightTree.count</span><br><span class="line">  ; left= <span class="type">HuffmanNode</span> leftTree</span><br><span class="line">  ; right= <span class="type">HuffmanNode</span> rightTree &#125;</span><br></pre></td></tr></table></figure>

<p><strong>新建一个叶子结点</strong></p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newHuffmanNode _data count : huffmanNode =</span><br><span class="line">  &#123;data= (<span class="type">Some</span> _data, count); count; left= <span class="type">Empty</span>; right= <span class="type">Empty</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构建一个哈夫曼优先队列</strong></p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="type">Huffman_priority_queue</span> = <span class="type">Make_priority_queue</span> (<span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">type</span> t = huffmanNode</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> compare left right = right.count - left.count</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<p><strong>创建初始状态</strong></p>
<p>即不断的通过新建结点的方式生成叶子结点并且<strong>push</strong>入优先队列中</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _huffmanQueue = <span class="built_in">ref</span> <span class="type">Huffman_priority_queue</span>.newQueue</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> buildInitialHuffmanQueue = <span class="keyword">function</span></span><br><span class="line">  | hd :: tl -&gt;</span><br><span class="line">      _huffmanQueue :=</span><br><span class="line">        <span class="type">Huffman_priority_queue</span>.push !_huffmanQueue</span><br><span class="line">          (newHuffmanNode (fst hd) (snd hd)) ;</span><br><span class="line">      buildInitialHuffmanQueue tl</span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">()</span></span><br></pre></td></tr></table></figure>

<p><strong>循环构建哈夫曼树</strong></p>
<p>因为这个操作用命令式语言的 while 循环会让思路变的比较清晰，所以这边还是选择了 while 来判断出口，或者为了 FP 的思想我们可以 match 队列的 size 来判断出口但是这样实在是有些牵强感觉，对于这种数据结构和算法而言还是 while 比较直观。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generateHuffmanTreeByPriorityQueue queue =</span><br><span class="line">  <span class="keyword">while</span> <span class="type">Huffman_priority_queue</span>.size !queue &lt;&gt; <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="type">Huffman_priority_queue</span>.top !queue <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> _ = queue := <span class="type">Huffman_priority_queue</span>.pop !queue <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="type">Huffman_priority_queue</span>.top !queue <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> _ = queue := <span class="type">Huffman_priority_queue</span>.pop !queue <span class="keyword">in</span></span><br><span class="line">    queue := <span class="type">Huffman_priority_queue</span>.push !queue (huffmanMergeTwoTree a b)</span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>根据树结构生成哈夫曼编码</strong></p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generateHuffmanCodeByTree tree =</span><br><span class="line">  <span class="keyword">let</span> code = <span class="built_in">ref</span> <span class="literal">[]</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> generateCode nowCode tree =</span><br><span class="line">    <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">    | <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">    | <span class="type">HuffmanNode</span> &#123;data; count; left; right&#125; -&gt; (</span><br><span class="line">      <span class="keyword">match</span> data <span class="keyword">with</span></span><br><span class="line">      | <span class="type">None</span>, _ -&gt;</span><br><span class="line">          generateCode (nowCode ^ <span class="string">&quot;0&quot;</span>) left ;</span><br><span class="line">          generateCode (nowCode ^ <span class="string">&quot;1&quot;</span>) right</span><br><span class="line">      | <span class="type">Some</span> _data, _ -&gt; code := (data, nowCode) :: !code ) <span class="keyword">in</span></span><br><span class="line">  generateCode <span class="string">&quot;&quot;</span> tree ; code</span><br></pre></td></tr></table></figure>

<h3 id="测试及结果"><a href="#测试及结果" class="headerlink" title="测试及结果"></a>测试及结果</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> testData = <span class="literal">[]</span></span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;b&#x27;</span>, <span class="number">40</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;c&#x27;</span>, <span class="number">20</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;d&#x27;</span>, <span class="number">80</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;e&#x27;</span>, <span class="number">90</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;f&#x27;</span>, <span class="number">30</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;g&#x27;</span>, <span class="number">888</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;h&#x27;</span>, <span class="number">66</span>) :: testData</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">buildInitialHuffmanQueue testData</span><br><span class="line"><span class="keyword">let</span> my_huffman_tree = generateHuffmanTreeByPriorityQueue _huffmanQueue</span><br><span class="line"><span class="keyword">let</span> treeTemp = <span class="type">HuffmanNode</span> (<span class="type">Huffman_priority_queue</span>.top !_huffmanQueue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> huffmanCode =</span><br><span class="line">  generateHuffmanCodeByTree (treeTemp)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">val treeTemp : huffmanTree =</span><br><span class="line">  HuffmanNode</span><br><span class="line">   &#123;data = (None, 1314); count = 1314;</span><br><span class="line">    left =</span><br><span class="line">     HuffmanNode</span><br><span class="line">      &#123;data = (None, 426); count = 426;</span><br><span class="line">       left =</span><br><span class="line">        HuffmanNode</span><br><span class="line">         &#123;data = (None, 180); count = 180;</span><br><span class="line">          left =</span><br><span class="line">           HuffmanNode</span><br><span class="line">            &#123;data = (Some <span class="string">&#x27;e&#x27;</span>, 90); count = 90;</span><br><span class="line">             left = Empty; right = Empty&#125;;</span><br><span class="line">          right =</span><br><span class="line">           HuffmanNode</span><br><span class="line">            &#123;data = (None, 90); count = 90;</span><br><span class="line">             left =</span><br><span class="line">              HuffmanNode</span><br><span class="line">               &#123;data = (Some <span class="string">&#x27;b&#x27;</span>, 40); count = 40;</span><br><span class="line">                left = Empty; right = Empty&#125;;</span><br><span class="line">             right =</span><br><span class="line">              HuffmanNode</span><br><span class="line">               &#123;data = (None, 50); count = 50;</span><br><span class="line">                left =</span><br><span class="line">                 HuffmanNode</span><br><span class="line">                  &#123;data = (Some <span class="string">&#x27;c&#x27;</span>, 20); count = 20;</span><br><span class="line">                   left = Empty; right = Empty&#125;;</span><br><span class="line">                right =</span><br><span class="line">                 HuffmanNode</span><br><span class="line">                  &#123;data = (Some <span class="string">&#x27;f&#x27;</span>, 30); count = 30;</span><br><span class="line">                   left = Empty; right = Empty&#125;&#125;&#125;&#125;;</span><br><span class="line">       right =</span><br><span class="line">        HuffmanNode</span><br><span class="line">         &#123;data = (None, 246); count = 246;</span><br><span class="line">          left =</span><br><span class="line">           HuffmanNode</span><br><span class="line">            &#123;data = (Some <span class="string">&#x27;a&#x27;</span>, 100); count = 100;</span><br><span class="line">             left = Empty; right = Empty&#125;;</span><br><span class="line">          right =</span><br><span class="line">           HuffmanNode</span><br><span class="line">            &#123;data = (None, 146); count = 146;</span><br><span class="line">             left =</span><br><span class="line">              HuffmanNode</span><br><span class="line">               &#123;data = (Some <span class="string">&#x27;h&#x27;</span>, 66); count = 66;</span><br><span class="line">                left = Empty; right = Empty&#125;;</span><br><span class="line">             right =</span><br><span class="line">              HuffmanNode</span><br><span class="line">               &#123;data = (Some <span class="string">&#x27;d&#x27;</span>, 80); count = 80;</span><br><span class="line">                left = Empty; right = Empty&#125;&#125;&#125;&#125;;</span><br><span class="line">    right =</span><br><span class="line">     HuffmanNode</span><br><span class="line">      &#123;data = (Some <span class="string">&#x27;g&#x27;</span>, 888); count = 888;</span><br><span class="line">       left = Empty; right = Empty&#125;&#125;</span><br><span class="line">val huffmanCode :</span><br><span class="line">  ((optional_char * int) * string) list ref =</span><br><span class="line">  &#123;contents =</span><br><span class="line">    [((Some <span class="string">&#x27;g&#x27;</span>, 888), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">     ((Some <span class="string">&#x27;d&#x27;</span>, 80), <span class="string">&quot;0111&quot;</span>);</span><br><span class="line">     ((Some <span class="string">&#x27;h&#x27;</span>, 66), <span class="string">&quot;0110&quot;</span>);</span><br><span class="line">     ((Some <span class="string">&#x27;a&#x27;</span>, 100), <span class="string">&quot;010&quot;</span>);</span><br><span class="line">     ((Some <span class="string">&#x27;f&#x27;</span>, 30), <span class="string">&quot;00111&quot;</span>);</span><br><span class="line">     ((Some <span class="string">&#x27;c&#x27;</span>, 20), <span class="string">&quot;00110&quot;</span>);</span><br><span class="line">     ((Some <span class="string">&#x27;b&#x27;</span>, 40), <span class="string">&quot;0010&quot;</span>);</span><br><span class="line">     ((Some <span class="string">&#x27;e&#x27;</span>, 90), <span class="string">&quot;000&quot;</span>)]&#125;</span><br></pre></td></tr></table></figure>

<p><b style="color: green">感谢观看</b></p>
<h2 id="Reference-tools"><a href="#Reference-tools" class="headerlink" title="Reference, tools"></a>Reference, tools</h2><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4965335/how-to-print-binary-tree-diagram">Java tree printer By Stackoverflow</a></p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/jj-issuu/8414570">Ocaml AVL Tree</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.realworldocaml.org/">Real World Ocaml</a></p>
<p><a target="_blank" rel="noopener" href="https://csacademy.com/app/graph_editor/">Graph Editor</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/15344069/deletion-in-binary-search-tree-in-ocaml">deletion in BST in ocaml By Stackoverflow</a></p>
<p>孙涵、高航等.数据结构抽象建模、实现与应用[M].北京:机械工业出版社.2020.130-140</p>
<h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h2><p>###AVL</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="type">Printf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="symbol">&#x27;a</span> tree = <span class="type">Empty</span> | <span class="type">Node</span> <span class="keyword">of</span> <span class="symbol">&#x27;a</span> * <span class="symbol">&#x27;a</span> tree * <span class="symbol">&#x27;a</span> tree</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> node =</span><br><span class="line">  <span class="type">Node</span></span><br><span class="line">    ( <span class="number">1</span></span><br><span class="line">    , <span class="type">Node</span> (<span class="number">5</span>, <span class="type">Node</span> (<span class="number">4</span>, <span class="type">Empty</span>, <span class="type">Empty</span>), <span class="type">Node</span> (<span class="number">2</span>, <span class="type">Empty</span>, <span class="type">Empty</span>))</span><br><span class="line">    , <span class="type">Node</span></span><br><span class="line">        (<span class="number">3</span>, <span class="type">Node</span> (<span class="number">10</span>, <span class="type">Empty</span>, <span class="type">Node</span> (<span class="number">17</span>, <span class="type">Empty</span>, <span class="type">Empty</span>)), <span class="type">Node</span> (<span class="number">14</span>, <span class="type">Empty</span>, <span class="type">Empty</span>))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> size = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="number">0</span></span><br><span class="line">  | <span class="type">Node</span> (_, left, right) -&gt; <span class="number">1</span> + size left + size right</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> preOrder = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) -&gt; <span class="type">Printf</span>.printf <span class="string">&quot;%d &quot;</span> v ; preOrder l ; preOrder r</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> midOrder = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) -&gt; midOrder l ; <span class="type">Printf</span>.printf <span class="string">&quot;%d &quot;</span> v ; midOrder r</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> postOrder = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) -&gt; postOrder l ; postOrder r ; <span class="type">Printf</span>.printf <span class="string">&quot;%d &quot;</span> v</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"><span class="type">Printf</span>.printf <span class="string">&quot;树的大小为%d\n&quot;</span> (size node) ;</span><br><span class="line">printf <span class="string">&quot;先序遍历\n&quot;</span> ;</span><br><span class="line">preOrder node ;</span><br><span class="line">printf <span class="string">&quot;\n中序遍历\n&quot;</span> ;</span><br><span class="line">midOrder node ;</span><br><span class="line">printf <span class="string">&quot;\n后序遍历\n&quot;</span> ;</span><br><span class="line">postOrder node</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 该函数是二叉排序树的插入函数，插入数值已存在时不产生任何动作，直接返回该结点  *)</span></span><br><span class="line"><span class="comment">(* 插入数值小于当前结点 当前数值不变，右子树不变，那么就需要把这个值插入到左子树 *)</span></span><br><span class="line"><span class="comment">(* 插入数值大于当前结点 当前数字不变，左子树不变，那么就需要把这个值插入到右子树 *)</span></span><br><span class="line"><span class="comment">(* 如果碰到了空结点，那么就代表寻找到了合适的插入位置，将其插入 *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> insert tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="type">Node</span> (<span class="keyword">value</span>, <span class="type">Empty</span>, <span class="type">Empty</span>)</span><br><span class="line">  | <span class="type">Node</span> (v, left, right) -&gt;</span><br><span class="line">      <span class="keyword">if</span> v = <span class="keyword">value</span> <span class="keyword">then</span> tree</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">value</span> &lt; v <span class="keyword">then</span> <span class="type">Node</span> (v, insert left <span class="keyword">value</span>, right)</span><br><span class="line">      <span class="keyword">else</span> <span class="type">Node</span> (v, left, insert right <span class="keyword">value</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 3-1-5-2-4-17-14-10 *)</span></span><br><span class="line"><span class="keyword">let</span> node = insert <span class="type">Empty</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">4</span></span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">17</span></span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">14</span></span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">10</span></span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">printf <span class="string">&quot;\n二叉排序树中序遍历\n&quot;</span> ;</span><br><span class="line">midOrder node</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> query tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">false</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) -&gt; v = <span class="keyword">value</span> || query l <span class="keyword">value</span> || query r <span class="keyword">value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> printBool = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">true</span> -&gt; printf <span class="string">&quot;结果为真\n&quot;</span></span><br><span class="line">  | <span class="literal">false</span> -&gt; printf <span class="string">&quot;结果为假\n&quot;</span></span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">print_endline <span class="string">&quot;&quot;</span> ;</span><br><span class="line">printBool (query node <span class="number">10</span>) ;</span><br><span class="line"><span class="comment">(* should be true *)</span></span><br><span class="line">printBool (query node <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(* should be false *)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* Print Helper *)</span></span><br><span class="line"><span class="keyword">let</span> eq a b = a = b</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 删除二叉排序树 *)</span></span><br><span class="line"><span class="comment">(* Thanks for the reference https://codereview.stackexchange.com/questions/187716/deleting-a-node-from-binary-tree-in-ocaml *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> mostRight = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; failwith <span class="string">&quot;结点存在一些问题&quot;</span></span><br><span class="line">  | <span class="type">Node</span> (v, _, <span class="type">Empty</span>) -&gt; v</span><br><span class="line">  | <span class="type">Node</span> (_, _, r) -&gt; mostRight r</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> delete tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="type">Empty</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) <span class="keyword">when</span> v &lt; <span class="keyword">value</span> -&gt; <span class="type">Node</span> (v, l, delete r <span class="keyword">value</span>)</span><br><span class="line">  | <span class="type">Node</span> (v, l, r) <span class="keyword">when</span> v &gt; <span class="keyword">value</span> -&gt; <span class="type">Node</span> (v, delete l <span class="keyword">value</span>, r)</span><br><span class="line">  | <span class="type">Node</span> (v, <span class="type">Empty</span>, <span class="type">Empty</span>) -&gt; <span class="type">Empty</span> <span class="comment">(* 直接删除自己 对应情况1 *)</span></span><br><span class="line">  | <span class="type">Node</span> (v, <span class="type">Empty</span>, r) -&gt; r <span class="comment">(* 情况2 删除自己 连接右子树*)</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, <span class="type">Empty</span>) -&gt; l <span class="comment">(* 情况2 删除自己 连接左子树*)</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) -&gt;</span><br><span class="line">      <span class="comment">(* 情况3，替换自己，删除原来的值 *)</span></span><br><span class="line">      <span class="keyword">let</span> newValue = mostRight l <span class="keyword">in</span></span><br><span class="line">      <span class="type">Node</span> (newValue, delete l newValue, r)</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 测试删除 *)</span></span><br><span class="line"><span class="keyword">let</span> delete2 = delete node <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> delete14 = delete node <span class="number">14</span></span><br><span class="line"><span class="keyword">let</span> delete3 = delete node <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> max x y = <span class="keyword">if</span> x &gt; y <span class="keyword">then</span> x <span class="keyword">else</span> y</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> getHeight = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="number">0</span></span><br><span class="line">  | <span class="type">Node</span> (_, l, r) -&gt; max (getHeight l) (getHeight r) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> pow base power = <span class="keyword">if</span> power = <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> base * pow base (power - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pow_tr base power =</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> _pow_tr base power sum =</span><br><span class="line">    <span class="keyword">if</span> power = <span class="number">0</span> <span class="keyword">then</span> sum <span class="keyword">else</span> _pow_tr base (power - <span class="number">1</span>) (base * sum) <span class="keyword">in</span></span><br><span class="line">  _pow_tr base power <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = getHeight node</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">printf <span class="string">&quot;树的高度 %d\n&quot;</span> h</span><br><span class="line"></span><br><span class="line"><span class="comment">(*</span></span><br><span class="line"><span class="comment">绘图规则</span></span><br><span class="line"><span class="comment">一行数字 一行辅助线</span></span><br><span class="line"><span class="comment">*)</span></span><br><span class="line"><span class="comment">(* ┌ ─ ┐ └ ┴ ┘*)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="symbol">&#x27;a</span> avlTree = <span class="type">Empty</span> | <span class="type">Node</span> <span class="keyword">of</span> <span class="symbol">&#x27;a</span> * <span class="symbol">&#x27;a</span> avlTree * <span class="symbol">&#x27;a</span> avlTree * <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> avlHeight = <span class="keyword">function</span> <span class="type">Empty</span> -&gt; <span class="number">0</span> | <span class="type">Node</span> (_, _, _, h) -&gt; h</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> makeNode <span class="keyword">value</span> leftTree rightTree =</span><br><span class="line">  <span class="type">Node</span></span><br><span class="line">    ( <span class="keyword">value</span></span><br><span class="line">    , leftTree</span><br><span class="line">    , rightTree</span><br><span class="line">    , <span class="number">1</span> + max (avlHeight leftTree) (avlHeight rightTree) )</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> find avlTreeNode <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> avlTreeNode <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">false</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r, _) -&gt; (</span><br><span class="line">    <span class="keyword">match</span> v = <span class="keyword">value</span> <span class="keyword">with</span></span><br><span class="line">    | <span class="literal">true</span> -&gt; <span class="literal">true</span></span><br><span class="line">    | <span class="literal">false</span> <span class="keyword">when</span> v &lt; <span class="keyword">value</span> -&gt; find l v</span><br><span class="line">    | <span class="literal">false</span> -&gt; find r v )</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 左旋 *)</span></span><br><span class="line"><span class="keyword">let</span> rotateLeft = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, <span class="type">Node</span> (_v, _l, _r, _), _) -&gt; makeNode _v (makeNode v l _l) _r</span><br><span class="line">  | _ -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* 右旋 *)</span></span><br><span class="line"><span class="keyword">let</span> rotateRight = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Node</span> (v, <span class="type">Node</span> (_v, _l, _r, _), r, _) -&gt; makeNode _v _l (makeNode v _r r)</span><br><span class="line">  | _ -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> insert tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="type">Node</span> (<span class="keyword">value</span>, <span class="type">Empty</span>, <span class="type">Empty</span>, <span class="number">1</span>)</span><br><span class="line">  | <span class="type">Node</span> (v, l, r, _) -&gt; (</span><br><span class="line">      <span class="keyword">if</span> v = <span class="keyword">value</span> <span class="keyword">then</span> tree</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">value</span> &lt; v <span class="keyword">then</span></span><br><span class="line">        <span class="comment">(* 如何判断插入之后是否需要左右旋转  我们需要插入后的树的高度 *)</span></span><br><span class="line">        <span class="keyword">match</span> insert l <span class="keyword">value</span> <span class="keyword">with</span></span><br><span class="line">        | <span class="type">Empty</span> -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br><span class="line">        | <span class="type">Node</span> (_v, _l, _r, _h) <span class="keyword">as</span> _node -&gt;</span><br><span class="line">            <span class="keyword">if</span> _h - avlHeight r &lt;= <span class="number">1</span> <span class="keyword">then</span> makeNode v _node r</span><br><span class="line">              <span class="comment">(* 直接插入这个结点不需要旋转 *)</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">let</span> _node =</span><br><span class="line">                <span class="comment">(* 根据前面的描述判断是否需要多旋转一次 *)</span></span><br><span class="line">                <span class="keyword">if</span> avlHeight _l &lt; avlHeight _r <span class="keyword">then</span> rotateLeft _node <span class="keyword">else</span> _node</span><br><span class="line">              <span class="keyword">in</span></span><br><span class="line">              rotateRight (makeNode v _node r) <span class="comment">(* L? 情况通用的右旋 *)</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">match</span> insert r <span class="keyword">value</span> <span class="keyword">with</span></span><br><span class="line">        | <span class="type">Empty</span> -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br><span class="line">        | <span class="type">Node</span> (_v, _l, _r, _h) <span class="keyword">as</span> _node -&gt;</span><br><span class="line">            <span class="keyword">if</span> _h - avlHeight l &lt;= <span class="number">1</span> <span class="keyword">then</span> makeNode v l _node</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">let</span> _node =</span><br><span class="line">                <span class="keyword">if</span> avlHeight _l &gt; avlHeight _r <span class="keyword">then</span> rotateRight _node <span class="keyword">else</span> _node</span><br><span class="line">              <span class="keyword">in</span></span><br><span class="line">              rotateLeft (makeNode v l _node) )</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> avlNode = insert <span class="type">Empty</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">30</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">25</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">34</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">37</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">39</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">22</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">16</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">13</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> avlMidOrder = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r, _) -&gt; avlMidOrder l ; printf <span class="string">&quot;%d &quot;</span> v ; avlMidOrder r</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">print_newline <span class="literal">()</span></span><br><span class="line">;;</span><br><span class="line">avlMidOrder avlNode</span><br></pre></td></tr></table></figure>

<h3 id="Huffman"><a href="#Huffman" class="headerlink" title="Huffman"></a>Huffman</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="type">Printf</span></span><br><span class="line"><span class="comment">(* 一个优先队列的简单实现，需要的是参数的类型和比较函数 *)</span></span><br><span class="line"><span class="keyword">module</span> <span class="keyword">type</span> <span class="type">Comparable</span> = <span class="keyword">sig</span></span><br><span class="line">  <span class="keyword">type</span> t</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> compare : t -&gt; t -&gt; <span class="built_in">int</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> <span class="type">Make_priority_queue</span> (<span class="type">QueueNode</span> : <span class="type">Comparable</span>) = <span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">let</span> top = <span class="keyword">function</span></span><br><span class="line">    | hd :: tl -&gt; hd</span><br><span class="line">    | <span class="literal">[]</span> -&gt; failwith <span class="string">&quot;没有更多结点了 Error on getTop&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pop = <span class="keyword">function</span></span><br><span class="line">    | hd :: tl -&gt; tl</span><br><span class="line">    | <span class="literal">[]</span> -&gt; failwith <span class="string">&quot;没有更多结点了 Error on pop&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> push queue <span class="keyword">value</span> =</span><br><span class="line">    <span class="keyword">match</span> queue <span class="keyword">with</span></span><br><span class="line">    | <span class="literal">[]</span> -&gt; [<span class="keyword">value</span>]</span><br><span class="line">    | hd :: tl -&gt;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">QueueNode</span>.compare <span class="keyword">value</span> hd &gt; <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">value</span> :: queue</span><br><span class="line">        <span class="keyword">else</span> hd :: push tl <span class="keyword">value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> size = <span class="keyword">function</span> _ :: tl -&gt; <span class="number">1</span> + size tl | <span class="literal">[]</span> -&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> empty = <span class="keyword">function</span> hd :: tl -&gt; <span class="literal">false</span> | <span class="literal">[]</span> -&gt; <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> newQueue : <span class="type">QueueNode</span>.t <span class="built_in">list</span> = <span class="literal">[]</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> <span class="type">Int_priority_queue</span> = <span class="type">Make_priority_queue</span> (<span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">type</span> t = <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> compare a b = a - b</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push <span class="literal">[]</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> int_priority_queue_print_helper = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">()</span></span><br><span class="line">  | hd :: tl -&gt;</span><br><span class="line">      <span class="type">Printf</span>.printf <span class="string">&quot;%d &quot;</span> hd ;</span><br><span class="line">      int_priority_queue_print_helper tl</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">printf <span class="string">&quot;\n&quot;</span></span><br><span class="line">;;</span><br><span class="line">int_priority_queue_print_helper priority_queue</span><br><span class="line">;;</span><br><span class="line">printf <span class="string">&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="built_in">ref</span> priority_queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> pop_all_elements queue_ref =</span><br><span class="line">  <span class="keyword">while</span> <span class="type">Int_priority_queue</span>.empty !queue_ref <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> queue_value_head = <span class="type">Int_priority_queue</span>.top !queue_ref <span class="keyword">in</span></span><br><span class="line">    printf <span class="string">&quot;%d &quot;</span> queue_value_head ;</span><br><span class="line">    queue_ref := <span class="type">Int_priority_queue</span>.pop !queue_ref</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">pop_all_elements priority_queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> optional_char = <span class="type">Some</span> <span class="keyword">of</span> <span class="built_in">char</span> | <span class="type">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* test for Some type *)</span></span><br><span class="line"><span class="keyword">module</span> <span class="type">Some_char_priority_queue</span> = <span class="type">Make_priority_queue</span> (<span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">type</span> t = optional_char * <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> compare a b = snd b - snd a</span><br><span class="line"></span><br><span class="line">  <span class="comment">(* 出现次数多的符号放在最后merge *)</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> huffman_queue = <span class="type">Some_char_priority_queue</span>.newQueue</span><br><span class="line"><span class="keyword">let</span> huffman_queue = <span class="type">Some_char_priority_queue</span>.push huffman_queue (<span class="type">Some</span> <span class="string">&#x27;a&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">let</span> huffman_queue = <span class="type">Some_char_priority_queue</span>.push huffman_queue (<span class="type">Some</span> <span class="string">&#x27;b&#x27;</span>, <span class="number">40</span>)</span><br><span class="line"><span class="keyword">let</span> huffman_queue = <span class="type">Some_char_priority_queue</span>.push huffman_queue (<span class="type">Some</span> <span class="string">&#x27;c&#x27;</span>, <span class="number">25</span>)</span><br><span class="line"><span class="keyword">let</span> huffman_queue = <span class="type">Some_char_priority_queue</span>.push huffman_queue (<span class="type">Some</span> <span class="string">&#x27;d&#x27;</span>, <span class="number">40</span>)</span><br><span class="line"><span class="keyword">let</span> huffman_queue = <span class="type">Some_char_priority_queue</span>.push huffman_queue (<span class="type">Some</span> <span class="string">&#x27;e&#x27;</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> huffman_queue = <span class="type">Some_char_priority_queue</span>.push huffman_queue (<span class="type">Some</span> <span class="string">&#x27;f&#x27;</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 定义哈夫曼树 *)</span></span><br><span class="line"><span class="keyword">type</span> huffmanTree = <span class="type">Empty</span> | <span class="type">HuffmanNode</span> <span class="keyword">of</span> huffmanNode</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> huffmanNode =</span><br><span class="line">  &#123;data: optional_char * <span class="built_in">int</span>; count: <span class="built_in">int</span>; left: huffmanTree; right: huffmanTree&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> huffmanMergeTwoTree leftTree rightTree : huffmanNode =</span><br><span class="line">  &#123; data= (<span class="type">None</span>, leftTree.count + rightTree.count)</span><br><span class="line">  ; count= leftTree.count + rightTree.count</span><br><span class="line">  ; left= <span class="type">HuffmanNode</span> leftTree</span><br><span class="line">  ; right= <span class="type">HuffmanNode</span> rightTree &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newHuffmanNode _data count : huffmanNode =</span><br><span class="line">  &#123;data= (<span class="type">Some</span> _data, count); count; left= <span class="type">Empty</span>; right= <span class="type">Empty</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> <span class="type">Huffman_priority_queue</span> = <span class="type">Make_priority_queue</span> (<span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">type</span> t = huffmanNode</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> compare left right = right.count - left.count</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(* dataList =&gt; char * int *)</span></span><br><span class="line"><span class="keyword">let</span> _huffmanQueue = <span class="built_in">ref</span> <span class="type">Huffman_priority_queue</span>.newQueue</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> buildInitialHuffmanQueue = <span class="keyword">function</span></span><br><span class="line">  | hd :: tl -&gt;</span><br><span class="line">      _huffmanQueue :=</span><br><span class="line">        <span class="type">Huffman_priority_queue</span>.push !_huffmanQueue</span><br><span class="line">          (newHuffmanNode (fst hd) (snd hd)) ;</span><br><span class="line">      buildInitialHuffmanQueue tl</span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testData = <span class="literal">[]</span></span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;b&#x27;</span>, <span class="number">40</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;c&#x27;</span>, <span class="number">20</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;d&#x27;</span>, <span class="number">80</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;e&#x27;</span>, <span class="number">90</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;f&#x27;</span>, <span class="number">30</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;g&#x27;</span>, <span class="number">888</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;h&#x27;</span>, <span class="number">66</span>) :: testData</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">buildInitialHuffmanQueue testData</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generateHuffmanTreeByPriorityQueue queue =</span><br><span class="line">  <span class="keyword">while</span> <span class="type">Huffman_priority_queue</span>.size !queue &lt;&gt; <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="type">Huffman_priority_queue</span>.top !queue <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> _ = queue := <span class="type">Huffman_priority_queue</span>.pop !queue <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="type">Huffman_priority_queue</span>.top !queue <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> _ = queue := <span class="type">Huffman_priority_queue</span>.pop !queue <span class="keyword">in</span></span><br><span class="line">    queue := <span class="type">Huffman_priority_queue</span>.push !queue (huffmanMergeTwoTree a b)</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my_huffman_tree = generateHuffmanTreeByPriorityQueue _huffmanQueue</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generateHuffmanCodeByTree tree =</span><br><span class="line">  <span class="keyword">let</span> code = <span class="built_in">ref</span> <span class="literal">[]</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> generateCode nowCode tree =</span><br><span class="line">    <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">    | <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">    | <span class="type">HuffmanNode</span> &#123;data; count; left; right&#125; -&gt; (</span><br><span class="line">      <span class="keyword">match</span> data <span class="keyword">with</span></span><br><span class="line">      | <span class="type">None</span>, _ -&gt;</span><br><span class="line">          generateCode (nowCode ^ <span class="string">&quot;0&quot;</span>) left ;</span><br><span class="line">          generateCode (nowCode ^ <span class="string">&quot;1&quot;</span>) right</span><br><span class="line">      | <span class="type">Some</span> _data, _ -&gt; code := (data, nowCode) :: !code ) <span class="keyword">in</span></span><br><span class="line">  generateCode <span class="string">&quot;&quot;</span> tree ; code</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> treeTemp = <span class="type">HuffmanNode</span> (<span class="type">Huffman_priority_queue</span>.top !_huffmanQueue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> huffmanCode =</span><br><span class="line">  generateHuffmanCodeByTree (treeTemp)</span><br></pre></td></tr></table></figure>

<h3 id="所有函数列表-AVL"><a href="#所有函数列表-AVL" class="headerlink" title="所有函数列表(AVL)"></a>所有函数列表(AVL)</h3><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="symbol">&#x27;a</span> tree = <span class="type">Empty</span> | <span class="type">Node</span> <span class="keyword">of</span> <span class="symbol">&#x27;a</span> * <span class="symbol">&#x27;a</span> tree * <span class="symbol">&#x27;a</span> tree</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> size : <span class="symbol">&#x27;a</span> tree -&gt; <span class="built_in">int</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> preOrder : <span class="built_in">int</span> tree -&gt; <span class="built_in">unit</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> midOrder : <span class="built_in">int</span> tree -&gt; <span class="built_in">unit</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> postOrder : <span class="built_in">int</span> tree -&gt; <span class="built_in">unit</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> insert : <span class="symbol">&#x27;a</span> tree -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> tree = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> query : <span class="symbol">&#x27;a</span> tree -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="built_in">bool</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> printBool : <span class="built_in">bool</span> -&gt; <span class="built_in">unit</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> eq : <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="built_in">bool</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> mostRight : <span class="symbol">&#x27;a</span> tree -&gt; <span class="symbol">&#x27;a</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> delete : <span class="symbol">&#x27;a</span> tree -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> tree = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> max : <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> getHeight : <span class="symbol">&#x27;a</span> tree -&gt; <span class="built_in">int</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> pow : <span class="built_in">int</span> -&gt; <span class="built_in">int</span> -&gt; <span class="built_in">int</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> pow_tr : <span class="built_in">int</span> -&gt; <span class="built_in">int</span> -&gt; <span class="built_in">int</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> h : <span class="built_in">int</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="symbol">&#x27;a</span> avlTree = <span class="type">Empty</span> | <span class="type">Node</span> <span class="keyword">of</span> <span class="symbol">&#x27;a</span> * <span class="symbol">&#x27;a</span> avlTree * <span class="symbol">&#x27;a</span> avlTree * <span class="built_in">int</span></span><br><span class="line"><span class="keyword">val</span> avlHeight : <span class="symbol">&#x27;a</span> avlTree -&gt; <span class="built_in">int</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> makeNode : <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> avlTree -&gt; <span class="symbol">&#x27;a</span> avlTree -&gt; <span class="symbol">&#x27;a</span> avlTree = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> find : <span class="symbol">&#x27;a</span> avlTree -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="built_in">bool</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> rotateLeft : <span class="symbol">&#x27;a</span> avlTree -&gt; <span class="symbol">&#x27;a</span> avlTree = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> rotateRight : <span class="symbol">&#x27;a</span> avlTree -&gt; <span class="symbol">&#x27;a</span> avlTree = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> insert : <span class="symbol">&#x27;a</span> avlTree -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> avlTree = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> avlMidOrder : <span class="built_in">int</span> avlTree -&gt; <span class="built_in">unit</span> = &lt;<span class="keyword">fun</span>&gt;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ocaml/" rel="tag"># ocaml</a>
              <a href="/tags/data-structure/" rel="tag"># data structure</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/posts/54798/" rel="next" title="C++文件库实践 filesystem">
      C++文件库实践 filesystem <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Ocaml-Tree-An-Intuitive-Tutorial"><span class="nav-number">1.</span> <span class="nav-text">Ocaml Tree, An Intuitive Tutorial</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A0%91"><span class="nav-number">1.1.</span> <span class="nav-text">基本树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">1.2.</span> <span class="nav-text">二叉查找树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.3.</span> <span class="nav-text">自平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RR-%E6%95%B0%E5%AD%97%E4%B8%8D%E4%BB%A3%E8%A1%A8%E6%95%B0%E5%80%BC%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.1.</span> <span class="nav-text">RR(数字不代表数值关系)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LL-%E6%95%B0%E5%AD%97%E4%B8%8D%E4%BB%A3%E8%A1%A8%E6%95%B0%E5%80%BC%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.2.</span> <span class="nav-text">LL(数字不代表数值关系)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RL-%E6%95%B0%E5%AD%97%E4%B8%8D%E4%BB%A3%E8%A1%A8%E6%95%B0%E5%80%BC%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.3.</span> <span class="nav-text">RL(数字不代表数值关系)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LR-%E6%95%B0%E5%AD%97%E4%BB%A3%E8%A1%A8%E6%95%B0%E5%80%BC%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.4.</span> <span class="nav-text">LR(数字代表数值关系)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%8F%B3%E6%97%8B"><span class="nav-number">1.3.5.</span> <span class="nav-text">左右旋</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BE%85%E5%8A%A9%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.6.</span> <span class="nav-text">编写二叉树辅助输出函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.7.</span> <span class="nav-text">具体实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E6%97%8B%E5%92%8C%E5%8F%B3%E6%97%8B"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">左旋和右旋</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LR-%E6%83%85%E5%86%B5%E5%88%A4%E6%96%AD-%E4%BB%A5%E5%8F%8A-%E5%B7%A6%E5%8F%B3%E6%97%8B%E8%BD%AC"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">LR 情况判断 以及 左右旋转</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%B5%8B%E8%AF%95"><span class="nav-number">1.3.8.</span> <span class="nav-text">插入测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LL"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">LL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LR"><span class="nav-number">1.3.8.2.</span> <span class="nav-text">LR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RL"><span class="nav-number">1.3.8.3.</span> <span class="nav-text">RL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E8%BE%83%E5%A4%9A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">1.3.8.4.</span> <span class="nav-text">插入较多的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9"><span class="nav-number">1.3.8.5.</span> <span class="nav-text">删除结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.8.6.</span> <span class="nav-text">排序数据输出(中序遍历)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">1.4.</span> <span class="nav-text">哈夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.1.</span> <span class="nav-text">定义哈夫曼树的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%8F%8A%E7%BB%93%E6%9E%9C"><span class="nav-number">1.4.2.</span> <span class="nav-text">测试及结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference-tools"><span class="nav-number">1.5.</span> <span class="nav-text">Reference, tools</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Source-Code"><span class="nav-number">1.6.</span> <span class="nav-text">Source Code</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Huffman"><span class="nav-number">1.6.1.</span> <span class="nav-text">Huffman</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8-AVL"><span class="nav-number">1.6.2.</span> <span class="nav-text">所有函数列表(AVL)</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">YuSheng Xu</p>
  <div class="site-description" itemprop="description">Study & Work & Life</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YuSheng Xu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">54k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">49 mins.</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
