<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MIT6.824</title>
    <url>/posts/61252/</url>
    <content><![CDATA[<h1 id="MIT6-824-Lab-学习笔记"><a href="#MIT6-824-Lab-学习笔记" class="headerlink" title="MIT6.824 Lab 学习笔记"></a>MIT6.824 Lab 学习笔记</h1><p>[toc]</p>
<p>本篇记录自己学习<a href="https://pdos.csail.mit.edu/6.824/">MIT6.824</a>的Lab记录，只记录思考过程，不记录具体的实现细节</p>
<p>环境</p>
<ul>
<li>WSL2 Ubuntu 22.04</li>
<li>Goland 最新版</li>
<li>Go 最新版</li>
</ul>
<h2 id="Lab1-MapReduce"><a href="#Lab1-MapReduce" class="headerlink" title="Lab1 - MapReduce"></a>Lab1 - MapReduce</h2><h3 id="一-测试原理窥探"><a href="#一-测试原理窥探" class="headerlink" title="一. 测试原理窥探"></a>一. 测试原理窥探</h3><p>首先观察<code>test-mr.sh</code>，也就是Lab1中提到的用以测试实现是否正确的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">maybe_quiet $TIMEOUT ../mrcoordinator ../pg*txt &amp;</span><br><span class="line">pid=$!</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">give the coordinator time to create the sockets.</span></span><br><span class="line">sleep 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start multiple workers.</span></span><br><span class="line">(maybe_quiet $TIMEOUT ../mrworker ../../mrapps/wc.so) &amp;</span><br><span class="line">(maybe_quiet $TIMEOUT ../mrworker ../../mrapps/wc.so) &amp;</span><br><span class="line">(maybe_quiet $TIMEOUT ../mrworker ../../mrapps/wc.so) &amp;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">wait</span> <span class="keyword">for</span> the coordinator to <span class="built_in">exit</span>.</span></span><br><span class="line">wait $pid</span><br></pre></td></tr></table></figure>

<p>从此处可得知测试的原理是启动一个<code>mrcoordinator</code> 和数个<code>mrworker</code>，通过本机rpc调用的形式模拟分布式场景。</p>
<p>同时，测试会通过<code>mrsequential</code>生成正确的答案，要做的主要是修改<code>rpc.go</code>,<code>worker.go</code>,<code>coordinator.go</code>这几个文件，其余文件暂时不需要进行修改。</p>
<p>在<code>coordinator</code> 文件中启动了rpc服务器，<code>mrworker</code>中根据命令行参数调用<code>LoadPlugin</code>加载<code>.so</code>文件中编译完成的map和reduce函数。在<code>coordinator</code>中，代码框架封装了一些网络通信的部分，其提供的<code>call</code>函数完成了参数的传递和回答的接收。</p>
<h3 id="二-运行原理及初期规划"><a href="#二-运行原理及初期规划" class="headerlink" title="二. 运行原理及初期规划"></a>二. 运行原理及初期规划</h3><h4 id="顺序MapReduce模型"><a href="#顺序MapReduce模型" class="headerlink" title="顺序MapReduce模型"></a>顺序MapReduce模型</h4><p>在Lab1的开始，指导中通过<code>mrsequential</code>生成正确的文件，我们先通过梳理<code>mrsequential</code>的方式逆推<code>MapReduce</code>的运行方式。</p>
<p><img src="/MIT6-824/image-20230605145850254.png" alt="image-20230605145850254"></p>
<p>可以看到，代码以顺序的方式对文件中的每个单词进行拆分，排序后，由Reduce函数负责计数，最终输出成一个文件作为结果，其中文件是每个单词的数量。</p>
<p>而我们要实现的版本就是并行的MapReduce模型，我们的Map和Reduce函数是不变的，但是File会分发给不同的Worker进行Map，Map完成后由Worker再进行Reduce，并输出成文件。</p>
<h4 id="细节补充"><a href="#细节补充" class="headerlink" title="细节补充"></a>细节补充</h4><p><code>mrsequential</code>的代码非常简单的描述了MapReduce的工作流程，下面补充一些MapReduce的细节(详见原文<a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">mapreduce.pdf</a>)，本处只是简单提了一下论文中提到的重要信息。</p>
<p><strong>Master结构</strong></p>
<ol>
<li>存储所有任务(Map,Reduce)的状态，包括未开始、进行中、已完成</li>
<li>中间结果的位置(location)和大小(size)，并将结果推送给进行reduce任务的worker</li>
</ol>
<p><strong>容错相关</strong></p>
<ol>
<li>Worker失效 —— Master会定期Ping每个Worker，无法回复Ping信号的Worker会被视作失败。同时将对应Worker的任务都重置为idle，同时因为每个Worker执行Map函数后会将文件存储在本地，因此完成的任务也需要重做。</li>
<li>Master失效 —— 可以通过Checkpoints恢复之前的进度，但是因为失效几率太低，所以论文之中没有实现。</li>
<li>多个Worker同时完成一个任务时，他们会先将要输出的文件命名为一个临时文件，在Go中可以使用<code>ioutil.TempFile</code>，待完成任务后，原子性(atomically)的对文件进行重命名，确保只有一份正确的结果。</li>
</ol>
<p><strong>可改善的细节</strong></p>
<ol>
<li>分区，针对Map产生的Key进行分桶策略</li>
<li>对中间结果进行Key排序</li>
<li>对于部分有大量重复Key的，可以在分发Reduce之前进行部分合并</li>
<li>…详见论文</li>
</ol>
<h4 id="规划Lab1"><a href="#规划Lab1" class="headerlink" title="规划Lab1"></a>规划Lab1</h4><p>结合上面所述，我认为Lab1可以分为如下几个阶段进行实现:</p>
<ul>
<li>基础通讯功能，包含<code>worker</code>向<code>coordinator</code>请求任务，<code>coordinator</code>返回当前任务阶段等</li>
<li>任务划分、进度收集功能，<code>coordinator</code>将任务分给<code>worker</code>并且回收结果</li>
<li><code>coordinator</code>统筹整个流程，对于失败的任务进行再分发</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><h2 id="参考网络上的答案并进行反思"><a href="#参考网络上的答案并进行反思" class="headerlink" title="参考网络上的答案并进行反思"></a>参考网络上的答案并进行反思</h2><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2>]]></content>
      <categories>
        <category>Lab</category>
      </categories>
      <tags>
        <tag>Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/posts/61255/</url>
    <content><![CDATA[<h1 id="刷题记录"><a href="#刷题记录" class="headerlink" title="刷题记录"></a>刷题记录</h1><h2 id="215-数组中的第-K-个最大元素"><a href="#215-数组中的第-K-个最大元素" class="headerlink" title="215. 数组中的第 K 个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第 K 个最大元素</a></h2><blockquote>
<p>解法:</p>
<ol>
<li><p>使用快速排序的划分思路，划分左右数组，根据左右数组的数量可以判断出要求的第 k 大元素在轴的左边还是右边</p>
</li>
<li><p>复杂度计算:</p>
<p>一次筛掉一半的元素 $\sum_{i&#x3D;0}^{i&#x3D;logN}(O(N&#x2F;2^i)) &#x3D; O(N)$</p>
</li>
</ol>
</blockquote>
<p>做的有点久，原因是对快速排序中的<strong>选择算法</strong>理解不够透彻，因为对于边界条件的判断过于混乱，因此在这里梳理一下边界条件。</p>
<p>选择算法通过选择某个数字作为基准，将比该数字小的数字放在该数左侧，比该数字大的数字放在该数右侧。也就是说，我们可以先将基准数字放在数组第一位，随后令 L 和 R 表示数组第二位和数组尾，循环判断要交换的一组(L,R)。注意此处由于编码的逻辑，L <strong>&lt;&#x3D;</strong> R ，因为 L 表示的是第一个比 pivot 小的数字的下标，因此当跳出这个循环时，L 位置的值是比 pivot 大的数字，L-1 位置的值是比 pivot 小的最远的数，和 pivot 对换即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;num, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rnd = [&amp;]() &#123; <span class="keyword">return</span> <span class="built_in">rand</span>() % (b - a + <span class="number">1</span>) + a; &#125;;</span><br><span class="line">    <span class="comment">// make partition</span></span><br><span class="line">    <span class="type">int</span> pivot = <span class="built_in">rnd</span>();</span><br><span class="line">    <span class="built_in">swap</span>(num[pivot], num[a]);</span><br><span class="line">    <span class="type">int</span> l = a + <span class="number">1</span>, r = b;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">      <span class="keyword">while</span> (l &lt;= r &amp;&amp; num[l] &lt;= num[a])</span><br><span class="line">        l++;</span><br><span class="line">      <span class="keyword">while</span> (l &lt;= r &amp;&amp; num[r] &gt;= num[a])</span><br><span class="line">        r--;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l &lt;= r)</span><br><span class="line">        <span class="built_in">swap</span>(num[l], num[r]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(num[a], num[l - <span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> leftCount = (l - <span class="number">1</span>) - a;</span><br><span class="line">    <span class="type">int</span> rightCount = b - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == leftCount + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> num[a + leftCount];</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= leftCount)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">find</span>(num, a, a + leftCount - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(num, a + leftCount + <span class="number">1</span>, b, k - leftCount - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums.<span class="built_in">size</span>() - k + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6394-字符串中的额外字符"><a href="#6394-字符串中的额外字符" class="headerlink" title="6394. 字符串中的额外字符"></a><a href="https://leetcode.cn/problems/extra-characters-in-a-string/">6394. 字符串中的额外字符</a></h2><blockquote>
<p>解法:</p>
<p>本题转换: 给 N 个空间，和无限种类的 M 个箱子，M 个箱子中的每个箱子只能放在空间中固定的几个位置，求最多覆盖多少空间。</p>
<p>因此可以用 DP 解决，DP[X]表示 0~X 空间下，最少留下多少个空余的空间</p>
<p>$DP[x + len] &#x3D; \min(DP[x],DP[x + len])$</p>
<p>$DP[x+1]&#x3D;DP[x]+1$</p>
<p>递推式只有两个，一个是可以从之前的最佳答案+1 递推过来，即不放任何箱子，另一个是从之前 len 个位置递推过来，表示 DP[x+len]从 DP[x]的最佳答案放置某个箱子过来</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minExtraChar</span><span class="params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> DP[s.<span class="built_in">size</span>() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//DP[x] 表示消耗字符串x长度后 最少留下几个</span></span><br><span class="line"></span><br><span class="line">        DP[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= s.<span class="built_in">size</span>() ; ++i) DP[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> st_pos = <span class="number">0</span>; st_pos &lt; s.<span class="built_in">size</span>() ; st_pos++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; d : dictionary) &#123;</span><br><span class="line">                <span class="keyword">if</span>(d.<span class="built_in">size</span>() + st_pos &lt;= s.<span class="built_in">size</span>() &amp;&amp; s.<span class="built_in">substr</span>(st_pos, d.<span class="built_in">size</span>()) == d)</span><br><span class="line">                    DP[st_pos + d.<span class="built_in">size</span>()] = <span class="built_in">min</span>(DP[st_pos + d.<span class="built_in">size</span>()], DP[st_pos]);</span><br><span class="line">            &#125;</span><br><span class="line">            DP[st_pos+<span class="number">1</span>] = <span class="built_in">min</span>(DP[st_pos + <span class="number">1</span>], DP[st_pos] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DP[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6464-最大公约数遍历"><a href="#6464-最大公约数遍历" class="headerlink" title="6464. 最大公约数遍历"></a><a href="https://leetcode.cn/problems/greatest-common-divisor-traversal/">6464. 最大公约数遍历</a></h2><blockquote>
<p>解法:</p>
<p>题目的本质是 有相同因子的数之间形成一条边，请问能否形成连通图</p>
<p>因此，此题可以使用并查集，并通过判断并查集的大小是否为所有数的个数，即可判断他们能否完全联通。</p>
<p>如 x &#x3D; 1024 则它应当只分解成 2，而不是 4，只需要质因数即可。可以用一个 map 来记录父结点的位置进行加速。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canTraverseAllPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//若A中集合可行遍</span></span><br><span class="line">        <span class="comment">//B只需与A中任意一个集合可以行遍即可</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fa</span><span class="params">(<span class="number">1e5</span> + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sz</span><span class="params">(<span class="number">1e5</span> + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">1e5</span> ; ++i) fa[i] = i, sz[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; getFa = [&amp;getFa,&amp;fa](<span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[x] == x) <span class="keyword">return</span> fa[x];</span><br><span class="line">            <span class="keyword">return</span> fa[x] = <span class="built_in">getFa</span>(fa[x]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> setFa = [&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;setFa &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">            <span class="type">int</span> fa_x = <span class="built_in">getFa</span>(x);</span><br><span class="line">            <span class="type">int</span> fa_y = <span class="built_in">getFa</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(fa_x != fa_y) &#123;</span><br><span class="line">                fa[fa_x] = fa_y;</span><br><span class="line">                sz[fa_y] += sz[fa_x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pos;</span><br><span class="line">        <span class="keyword">auto</span> handle_num = [&amp;](<span class="type">int</span> factor,<span class="type">int</span> index)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos.<span class="built_in">count</span>(factor) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">setFa</span>(index, pos[factor]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pos[factor] = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> idx&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; num : nums) &#123;</span><br><span class="line">            <span class="comment">//分解num</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">2</span>; x * x &lt;= num ; ++x) &#123;</span><br><span class="line">                <span class="keyword">if</span>(num % x == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">handle_num</span>(x, idx);</span><br><span class="line">                    num /= x;</span><br><span class="line">                    <span class="keyword">while</span>(num % x == <span class="number">0</span>) num /= x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">1</span>) <span class="built_in">handle_num</span>(num, idx);</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sz[<span class="built_in">getFa</span>(<span class="number">0</span>)] == nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>C++文件库实践 filesystem</title>
    <url>/posts/54798/</url>
    <content><![CDATA[<h1 id="C-Filesystem-library"><a href="#C-Filesystem-library" class="headerlink" title="C++ Filesystem library"></a>C++ Filesystem library</h1><blockquote>
<p>该<code>文件系统库</code>可能会因为操作系统的实现方式的不同产生不同的结果，如<strong>FAT</strong>系统没有软链接(Symbolic Links)和多份硬链接(Hardlinks)，如果同时有多个线程、进程、计算机操作同一个文件系统对象，则行为为未定义(undefined)</p>
</blockquote>
<p>文件一共分为以下几种类型：</p>
<ul>
<li>文件夹(directory)</li>
<li>常规文件(regular file)</li>
<li>硬链接(hard link)</li>
<li>软链接(symbolic link)</li>
</ul>
<p>文件路径也分为三种：</p>
<ul>
<li>绝对路径(absolute path)</li>
<li>相对路径(relative path)</li>
<li>canonical path</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>该文章旨在利用 C++标准库<code>filesystem</code>实现一个计算文件夹大小的功能，获取一下所有大于<code>512MB</code>的文件夹，先看一看程序的运行效果</p>
<p><strong>运行中</strong></p>
<p><img src="/learnCPPFileSystem/1.png" alt="1"></p>
<p><strong>结果</strong></p>
<p><img src="/learnCPPFileSystem/2.png" alt="2"></p>
<p>看出来效果还是很成功的，一共遍历了 206 万个文件，找到了网易云音乐，照片图库，flutter 的安装目录等这些大于 512MB 的文件位置，同时不会出现文件夹包含，如 A 文件夹中有 B、C 两个大于 512MB 的文件，那么只会列入 B 和 C，而不会再列入 A。</p>
<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="path类"><a href="#path类" class="headerlink" title="path类"></a><code>path</code>类</h3><p>用来表明一个文件路径。</p>
<p>可以是:</p>
<ul>
<li>绝对路径，如<code>/usr/local/bin/</code></li>
<li>相对路径，如<code>./</code></li>
</ul>
<p>可以通过地址去构造一个<code>path</code>类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::filesystem::path p = <span class="string">&quot;your path&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="directory-iterator类"><a href="#directory-iterator类" class="headerlink" title="directory_iterator类"></a><code>directory_iterator</code>类</h3><p>非递归的遍历所有文件，即跳过文件夹</p>
<h3 id="recursive-directory-iterator类"><a href="#recursive-directory-iterator类" class="headerlink" title="recursive_directory_iterator类"></a><code>recursive_directory_iterator</code>类</h3><p>相比<code>directory_iterator</code>可以同时遍历文件夹</p>
<h3 id="directory-entry类"><a href="#directory-entry类" class="headerlink" title="directory_entry类"></a><code>directory_entry</code>类</h3><p>从<code>iterator</code>类中用来遍历的迭代器，包含文件路径，额外的文件信息(包括文件类型，文件权限，文件大小…)</p>
<p>获取文件类型的函数通常是<code>is_xxx</code>开头</p>
<p><strong>举例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : std::filesystem::<span class="built_in">directory_iterator</span>(<span class="string">&quot;./testDir&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span>(p.<span class="built_in">is_regular_file</span>()) std::cout &lt;&lt; p.<span class="built_in">path</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="current-path函数"><a href="#current-path函数" class="headerlink" title="current_path函数"></a><code>current_path</code>函数</h3><p>获取&#x2F;设置当前目录</p>
<h3 id="last-write-time函数"><a href="#last-write-time函数" class="headerlink" title="last_write_time函数"></a><code>last_write_time</code>函数</h3><p>获取&#x2F;设置文件的最后修改时间</p>
<h3 id="remove、remove-all函数"><a href="#remove、remove-all函数" class="headerlink" title="remove、remove_all函数"></a><code>remove</code>、<code>remove_all</code>函数</h3><p>删除&#x2F;删除所有的文件</p>
<h3 id="rename函数"><a href="#rename函数" class="headerlink" title="rename函数"></a><code>rename</code>函数</h3><p>重命名</p>
<p>这四个函数都是采用<code>path</code>类作为主要的参数，这些参数都可以通过字符串字面量提供。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="定义数据类型"><a href="#定义数据类型" class="headerlink" title="定义数据类型"></a>定义数据类型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> u32 = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">fileType</span></span><br><span class="line">    &#123;</span><br><span class="line">        fs_regular_file = <span class="number">0</span>,</span><br><span class="line">        fs_directory = <span class="number">1</span>,</span><br><span class="line">        fs_symlink = <span class="number">2</span>,</span><br><span class="line">        fs_other = <span class="number">3</span>,</span><br><span class="line">        fs_root = <span class="number">4</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">sizeUnit</span></span><br><span class="line">    &#123;</span><br><span class="line">        sz_byte = <span class="number">0</span>,</span><br><span class="line">        sz_kb = <span class="number">1</span>,</span><br><span class="line">        sz_mb = <span class="number">2</span>,</span><br><span class="line">        sz_gb = <span class="number">3</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace type</span></span><br></pre></td></tr></table></figure>

<p>分别表示文件类型，和存储单位</p>
<h3 id="定义单位转换函数"><a href="#定义单位转换函数" class="headerlink" title="定义单位转换函数"></a>定义单位转换函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> util</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">convert_byte_to_unit</span><span class="params">(type::u32 size, type::sizeUnit unit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        type::u32 divisor = (<span class="number">1</span> &lt;&lt; (unit * <span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(size) / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(divisor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">type::u32 <span class="title">convert_unit_to_byte</span><span class="params">(<span class="type">double</span> value, type::sizeUnit unit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RELEASE</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;您正在使用不被推荐的函数 convert_unit_to_byte&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        type::u32 factor = (<span class="number">1</span> &lt;&lt; (unit * <span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(factor * value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// namespace util</span></span><br></pre></td></tr></table></figure>

<h3 id="定义存储文件的结构体"><a href="#定义存储文件的结构体" class="headerlink" title="定义存储文件的结构体"></a>定义存储文件的结构体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    fs::file_time_type last_write_time;              <span class="comment">//最后修改时间</span></span><br><span class="line">    std::string name;                                <span class="comment">//结点的名字</span></span><br><span class="line">    std::string prefix;                              <span class="comment">//结点的前缀 用来计算下一个结点用</span></span><br><span class="line">    type::u32 size&#123;&#125;;                                <span class="comment">//结点的大小 Byte(s)</span></span><br><span class="line">    type::fileType filetype;                         <span class="comment">//结点的类型</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; fileMap&#123;&#125;;            <span class="comment">//索引 名字-&gt;编号</span></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;node&gt;&gt; nodeHolder&#123;&#125;; <span class="comment">//所有结点的索引</span></span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">const</span> std::string &amp;_prefix, <span class="type">const</span> std::string &amp;_name, <span class="type">const</span> type::fileType &amp;_filetype)</span><br><span class="line">        : <span class="built_in">prefix</span>(_prefix), <span class="built_in">name</span>(_name), <span class="built_in">filetype</span>(_filetype) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="定义文件遍历的相关操作"><a href="#定义文件遍历的相关操作" class="headerlink" title="定义文件遍历的相关操作"></a>定义文件遍历的相关操作</h3><h4 id="文件树创建"><a href="#文件树创建" class="headerlink" title="文件树创建"></a>文件树创建</h4><p>递归建树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildFSTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fs::<span class="built_in">current_path</span>(<span class="built_in">static_cast</span>&lt;fs::path&gt;(<span class="keyword">this</span>-&gt;prefix));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p : fs::<span class="built_in">directory_iterator</span>(<span class="string">&quot;./&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::string actual_name = <span class="built_in">static_cast</span>&lt;std::string&gt;(p.<span class="built_in">path</span>()).<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">        cerr &lt;&lt; <span class="string">&#x27;\r&#x27;</span> &lt;&lt; ++totCnt &lt;&lt; <span class="string">&quot; files walked &quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; <span class="built_in">slice_string_under_length</span>(<span class="keyword">this</span>-&gt;prefix + actual_name, <span class="number">90</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; actual_name &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">is_directory</span>() &amp;&amp; !p.<span class="built_in">is_symlink</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 递归扫描</span></span><br><span class="line">            <span class="keyword">auto</span> temp = std::<span class="built_in">make_unique</span>&lt;node&gt;(node&#123;<span class="keyword">this</span>-&gt;prefix + actual_name + <span class="string">&quot;/&quot;</span>, actual_name, type::fileType::fs_directory&#125;);</span><br><span class="line">            temp-&gt;last_write_time = p.<span class="built_in">last_write_time</span>();</span><br><span class="line">            temp-&gt;<span class="built_in">buildFSTree</span>();</span><br><span class="line">            fs::<span class="built_in">current_path</span>(<span class="built_in">static_cast</span>&lt;fs::path&gt;(<span class="keyword">this</span>-&gt;prefix));</span><br><span class="line">            nodeHolder.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(temp));</span><br><span class="line">            fileMap.<span class="built_in">insert</span>(&#123;p.<span class="built_in">path</span>(), nodeHolder.<span class="built_in">size</span>() - <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.<span class="built_in">is_symlink</span>())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">auto</span> temp = std::<span class="built_in">make_unique</span>&lt;node&gt;(node&#123;<span class="keyword">this</span>-&gt;prefix + actual_name + <span class="string">&quot;/&quot;</span>, actual_name, type::fileType::fs_regular_file&#125;);</span><br><span class="line">            <span class="keyword">if</span> (p.<span class="built_in">is_regular_file</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                temp-&gt;filetype = type::fileType::fs_regular_file;</span><br><span class="line">                temp-&gt;last_write_time = p.<span class="built_in">last_write_time</span>();</span><br><span class="line">                temp-&gt;size = p.<span class="built_in">file_size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp-&gt;filetype = type::fileType::fs_other;</span><br><span class="line"></span><br><span class="line">            nodeHolder.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(temp));</span><br><span class="line">            fileMap.<span class="built_in">insert</span>(&#123;p.<span class="built_in">path</span>(), nodeHolder.<span class="built_in">size</span>() - <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取大小"><a href="#获取大小" class="headerlink" title="获取大小"></a>获取大小</h4><p>显然是一个递归操作，我们对于文件树上的每个节点求和，如果该节点是文件夹，那么先递归求解文件夹里的内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">calcSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// this-&gt;size = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;_node : <span class="keyword">this</span>-&gt;nodeHolder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_node-&gt;filetype == type::fileType::fs_directory)</span><br><span class="line">        &#123;</span><br><span class="line">            _node-&gt;<span class="built_in">calcSize</span>();</span><br><span class="line">            <span class="keyword">this</span>-&gt;size += _node-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_node-&gt;filetype == type::fileType::fs_regular_file)</span><br><span class="line">            <span class="keyword">this</span>-&gt;size += _node-&gt;size;</span><br><span class="line">        <span class="comment">// else discard</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断大于指定字节数的内容"><a href="#判断大于指定字节数的内容" class="headerlink" title="判断大于指定字节数的内容"></a>判断大于指定字节数的内容</h4><p>和上一个函数一样，递归判断，需要注意，如果该目录大于 512MB，下级目录也大于 512MB，那么该目录不应该显示上去，我们只显示最深层的大于 512MB 的目录，所以我们要有两个判断，一个判断是否大于 512MB 告诉上级的 Node 我们不需要输出了，一个用来判断下级给来的 bool 用<code>check</code>变量判断我们到底要不要输出了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">print_more_than</span><span class="params">(type::u32 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;filetype != type::fileType::fs_regular_file &amp;&amp; <span class="keyword">this</span>-&gt;filetype != type::fileType::fs_directory)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> check = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;item : <span class="keyword">this</span>-&gt;nodeHolder)</span><br><span class="line">        check |= item-&gt;<span class="built_in">print_more_than</span>(sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!check &amp;&amp; <span class="keyword">this</span>-&gt;size &gt; sz)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;条目: &quot;</span> &lt;&lt; (<span class="keyword">this</span>-&gt;filetype == type::fileType::fs_directory ? <span class="keyword">this</span>-&gt;prefix : <span class="keyword">this</span>-&gt;prefix.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="keyword">this</span>-&gt;prefix.<span class="built_in">size</span>() - <span class="number">1</span>))</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 大小: &quot;</span> &lt;&lt; util::<span class="built_in">convert_byte_to_unit</span>(<span class="keyword">this</span>-&gt;size, type::sizeUnit::sz_mb) &lt;&lt; <span class="string">&quot; MB&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">print_time</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;size &gt; sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件树类"><a href="#文件树类" class="headerlink" title="文件树类"></a>文件树类</h3><p>用来保存指定目录的根结点，通过构造函数完成建造树的过程，是对 Node 结点的一个封装</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">filesystem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;node&gt; root&#123;&#125;;</span><br><span class="line">    std::string cur_path&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">filesystem</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">(type::u32 sz)</span></span>;</span><br><span class="line">    ~<span class="built_in">filesystem</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filesystem::detect</span><span class="params">(type::u32 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root-&gt;<span class="built_in">print_more_than</span>(sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filesystem::debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p : <span class="keyword">this</span>-&gt;root-&gt;nodeHolder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> printable_time = <span class="keyword">decltype</span>(p-&gt;last_write_time)::clock::<span class="built_in">to_time_t</span>(p-&gt;last_write_time);</span><br><span class="line">        cout &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; size-&gt; &quot;</span> &lt;&lt; util::<span class="built_in">convert_byte_to_unit</span>(p-&gt;size, type::sizeUnit::sz_mb)</span><br><span class="line">             &lt;&lt; <span class="string">&quot;MB&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p-&gt;size &lt;&lt; <span class="string">&quot; time-&gt; &quot;</span></span><br><span class="line">             &lt;&lt; std::<span class="built_in">asctime</span>(std::<span class="built_in">localtime</span>(&amp;printable_time)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filesystem::<span class="built_in">filesystem</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化root结点，即`/`</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;root = std::<span class="built_in">make_unique</span>&lt;node&gt;();</span><br><span class="line">    <span class="keyword">this</span>-&gt;root-&gt;name = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root-&gt;size = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root-&gt;prefix = <span class="string">&quot;/Users/xys/&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root-&gt;filetype = type::fileType::fs_directory;</span><br><span class="line">    <span class="comment">// 开始建立文件树</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;构造文件树 &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;root-&gt;prefix &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root-&gt;<span class="built_in">buildFSTree</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;计算树上结点空间占用&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root-&gt;<span class="built_in">calcSize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接下来可以做什么？"><a href="#接下来可以做什么？" class="headerlink" title="接下来可以做什么？"></a>接下来可以做什么？</h3><ul>
<li>根据时间排序，找出不怎么修改的大文件夹</li>
<li>设定更多的搜索条件</li>
<li>利用文件树类，实现一个简易的文件搜索工具</li>
</ul>
<h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout, std::cin, std::cerr;</span><br><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> u32 = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">fileType</span></span><br><span class="line">    &#123;</span><br><span class="line">        fs_regular_file = <span class="number">0</span>,</span><br><span class="line">        fs_directory = <span class="number">1</span>,</span><br><span class="line">        fs_symlink = <span class="number">2</span>,</span><br><span class="line">        fs_other = <span class="number">3</span>,</span><br><span class="line">        fs_root = <span class="number">4</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">sizeUnit</span></span><br><span class="line">    &#123;</span><br><span class="line">        sz_byte = <span class="number">0</span>,</span><br><span class="line">        sz_kb = <span class="number">1</span>,</span><br><span class="line">        sz_mb = <span class="number">2</span>,</span><br><span class="line">        sz_gb = <span class="number">3</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> util</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">convert_byte_to_unit</span><span class="params">(type::u32 size, type::sizeUnit unit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        type::u32 divisor = (<span class="number">1</span> &lt;&lt; (unit * <span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(size) / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(divisor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">type::u32 <span class="title">convert_unit_to_byte</span><span class="params">(<span class="type">double</span> value, type::sizeUnit unit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RELEASE</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;您正在使用不被推荐的函数 convert_unit_to_byte&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        type::u32 factor = (<span class="number">1</span> &lt;&lt; (unit * <span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(factor * value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// namespace util</span></span><br><span class="line"><span class="type">int</span> totCnt&#123;&#125;;</span><br><span class="line"><span class="function">std::string <span class="title">slice_string_under_length</span><span class="params">(std::string a, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">length</span>() &gt; len)</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">substr</span>(<span class="number">0</span>, len / <span class="number">2</span>) + <span class="string">&quot;.......&quot;</span> + a.<span class="built_in">substr</span>(a.<span class="built_in">length</span>() - len / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    fs::file_time_type last_write_time;              <span class="comment">//最后修改时间</span></span><br><span class="line">    std::string name;                                <span class="comment">//结点的名字</span></span><br><span class="line">    std::string prefix;                              <span class="comment">//结点的前缀 用来计算下一个结点用</span></span><br><span class="line">    type::u32 size&#123;&#125;;                                <span class="comment">//结点的大小 Byte(s)</span></span><br><span class="line">    type::fileType filetype;                         <span class="comment">//结点的类型</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; fileMap&#123;&#125;;            <span class="comment">//索引 名字-&gt;编号</span></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;node&gt;&gt; nodeHolder&#123;&#125;; <span class="comment">//所有结点的索引</span></span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">const</span> std::string &amp;_prefix, <span class="type">const</span> std::string &amp;_name, <span class="type">const</span> type::fileType &amp;_filetype)</span><br><span class="line">        : <span class="built_in">prefix</span>(_prefix), <span class="built_in">name</span>(_name), <span class="built_in">filetype</span>(_filetype) &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getNextPath</span><span class="params">(<span class="type">const</span> std::string &amp;filename)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefix + name + <span class="string">&quot;/&quot;</span> + filename;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> printable_time = <span class="keyword">decltype</span>(<span class="keyword">this</span>-&gt;last_write_time)::clock::<span class="built_in">to_time_t</span>(<span class="keyword">this</span>-&gt;last_write_time);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">asctime</span>(std::<span class="built_in">localtime</span>(&amp;printable_time));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calcSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this-&gt;size = 0;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;_node : <span class="keyword">this</span>-&gt;nodeHolder)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_node-&gt;filetype == type::fileType::fs_directory)</span><br><span class="line">            &#123;</span><br><span class="line">                _node-&gt;<span class="built_in">calcSize</span>();</span><br><span class="line">                <span class="keyword">this</span>-&gt;size += _node-&gt;size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (_node-&gt;filetype == type::fileType::fs_regular_file)</span><br><span class="line">                <span class="keyword">this</span>-&gt;size += _node-&gt;size;</span><br><span class="line">            <span class="comment">// else discard</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">print_more_than</span><span class="params">(type::u32 sz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;filetype != type::fileType::fs_regular_file &amp;&amp; <span class="keyword">this</span>-&gt;filetype != type::fileType::fs_directory)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> check = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;item : <span class="keyword">this</span>-&gt;nodeHolder)</span><br><span class="line">            check |= item-&gt;<span class="built_in">print_more_than</span>(sz);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!check &amp;&amp; <span class="keyword">this</span>-&gt;size &gt; sz)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;条目: &quot;</span> &lt;&lt; (<span class="keyword">this</span>-&gt;filetype == type::fileType::fs_directory ? <span class="keyword">this</span>-&gt;prefix : <span class="keyword">this</span>-&gt;prefix.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="keyword">this</span>-&gt;prefix.<span class="built_in">size</span>() - <span class="number">1</span>))</span><br><span class="line">                 &lt;&lt; <span class="string">&quot; 大小: &quot;</span> &lt;&lt; util::<span class="built_in">convert_byte_to_unit</span>(<span class="keyword">this</span>-&gt;size, type::sizeUnit::sz_mb) &lt;&lt; <span class="string">&quot; MB&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">print_time</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;size &gt; sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildFSTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        fs::<span class="built_in">current_path</span>(<span class="built_in">static_cast</span>&lt;fs::path&gt;(<span class="keyword">this</span>-&gt;prefix));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p : fs::<span class="built_in">directory_iterator</span>(<span class="string">&quot;./&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            std::string actual_name = <span class="built_in">static_cast</span>&lt;std::string&gt;(p.<span class="built_in">path</span>()).<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">            cerr &lt;&lt; <span class="string">&#x27;\r&#x27;</span> &lt;&lt; ++totCnt &lt;&lt; <span class="string">&quot; files walked &quot;</span></span><br><span class="line">                 &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; <span class="built_in">slice_string_under_length</span>(<span class="keyword">this</span>-&gt;prefix + actual_name, <span class="number">90</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; actual_name &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">            <span class="keyword">if</span> (p.<span class="built_in">is_directory</span>() &amp;&amp; !p.<span class="built_in">is_symlink</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 递归扫描</span></span><br><span class="line">                <span class="keyword">auto</span> temp = std::<span class="built_in">make_unique</span>&lt;node&gt;(node&#123;<span class="keyword">this</span>-&gt;prefix + actual_name + <span class="string">&quot;/&quot;</span>, actual_name, type::fileType::fs_directory&#125;);</span><br><span class="line">                temp-&gt;last_write_time = p.<span class="built_in">last_write_time</span>();</span><br><span class="line">                temp-&gt;<span class="built_in">buildFSTree</span>();</span><br><span class="line">                fs::<span class="built_in">current_path</span>(<span class="built_in">static_cast</span>&lt;fs::path&gt;(<span class="keyword">this</span>-&gt;prefix));</span><br><span class="line">                nodeHolder.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(temp));</span><br><span class="line">                fileMap.<span class="built_in">insert</span>(&#123;p.<span class="built_in">path</span>(), nodeHolder.<span class="built_in">size</span>() - <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.<span class="built_in">is_symlink</span>())</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">auto</span> temp = std::<span class="built_in">make_unique</span>&lt;node&gt;(node&#123;<span class="keyword">this</span>-&gt;prefix + actual_name + <span class="string">&quot;/&quot;</span>, actual_name, type::fileType::fs_regular_file&#125;);</span><br><span class="line">                <span class="keyword">if</span> (p.<span class="built_in">is_regular_file</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    temp-&gt;filetype = type::fileType::fs_regular_file;</span><br><span class="line">                    temp-&gt;last_write_time = p.<span class="built_in">last_write_time</span>();</span><br><span class="line">                    temp-&gt;size = p.<span class="built_in">file_size</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    temp-&gt;filetype = type::fileType::fs_other;</span><br><span class="line"></span><br><span class="line">                nodeHolder.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(temp));</span><br><span class="line">                fileMap.<span class="built_in">insert</span>(&#123;p.<span class="built_in">path</span>(), nodeHolder.<span class="built_in">size</span>() - <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">filesystem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;node&gt; root&#123;&#125;;</span><br><span class="line">    std::string cur_path&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">filesystem</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">(type::u32 sz)</span></span>;</span><br><span class="line">    ~<span class="built_in">filesystem</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filesystem::detect</span><span class="params">(type::u32 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root-&gt;<span class="built_in">print_more_than</span>(sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filesystem::debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p : <span class="keyword">this</span>-&gt;root-&gt;nodeHolder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> printable_time = <span class="keyword">decltype</span>(p-&gt;last_write_time)::clock::<span class="built_in">to_time_t</span>(p-&gt;last_write_time);</span><br><span class="line">        cout &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; size-&gt; &quot;</span> &lt;&lt; util::<span class="built_in">convert_byte_to_unit</span>(p-&gt;size, type::sizeUnit::sz_mb)</span><br><span class="line">             &lt;&lt; <span class="string">&quot;MB&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p-&gt;size &lt;&lt; <span class="string">&quot; time-&gt; &quot;</span></span><br><span class="line">             &lt;&lt; std::<span class="built_in">asctime</span>(std::<span class="built_in">localtime</span>(&amp;printable_time)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filesystem::<span class="built_in">filesystem</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化root结点，即`/`</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;root = std::<span class="built_in">make_unique</span>&lt;node&gt;();</span><br><span class="line">    <span class="keyword">this</span>-&gt;root-&gt;name = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root-&gt;size = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root-&gt;prefix = <span class="string">&quot;/Users/xys/&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root-&gt;filetype = type::fileType::fs_directory;</span><br><span class="line">    <span class="comment">// 开始建立文件树</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;构造文件树 &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;root-&gt;prefix &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root-&gt;<span class="built_in">buildFSTree</span>();</span><br><span class="line">    cerr &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;计算树上结点空间占用&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root-&gt;<span class="built_in">calcSize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">self_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// testConvert</span></span><br><span class="line">    <span class="type">int</span> source, recover;</span><br><span class="line">    source = <span class="number">0xffff</span>;</span><br><span class="line">    <span class="type">double</span> byte_2_mb = util::<span class="built_in">convert_byte_to_unit</span>(source, type::sizeUnit::sz_mb);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bytes: &quot;</span> &lt;&lt; source &lt;&lt; <span class="string">&quot; mbs: &quot;</span> &lt;&lt; byte_2_mb &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    recover = util::<span class="built_in">convert_unit_to_byte</span>(byte_2_mb, type::sizeUnit::sz_mb);</span><br><span class="line">    <span class="built_in">assert</span>(recover == source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RELEASE</span></span><br><span class="line">    <span class="comment">// self_test();</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;自检通过&quot;;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欢迎使用文件大小统计功能&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    filesystem fsTree&#123;&#125;;</span><br><span class="line">    <span class="comment">// fsTree.debug();</span></span><br><span class="line">    <span class="comment">// 输出所有大于512MB的文件夹的位置</span></span><br><span class="line">    <span class="comment">// 检测逻辑，如果这个文件夹大于500MB同时下级目录没有大于512MB的</span></span><br><span class="line">    fsTree.<span class="built_in">detect</span>(util::<span class="built_in">convert_unit_to_byte</span>(<span class="number">512.0</span>, type::sizeUnit::sz_mb));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h2><p><a href="https://en.cppreference.com/w/cpp/filesystem">cpp reference</a></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>std_library</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust ML with tch-rs</title>
    <url>/posts/45670/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In this post, we use <a href="https://github.com/LaurentMazare/tch-rs">tch-rs</a> and <a href="https://github.com/serde-rs/serde">serde</a> to do multi-classification tasks.</p>
<p>To configure the tch-rs is really struggling, please follow the tch-rs github page to configure everything for your specific OS system.</p>
<p>The dataset is similar to <a href="https://www.kaggle.com/datasets/ruthgn/wine-quality-data-set-red-white-wine">Wine Quality</a> but with some modifications bacause it is my homework, the teaching assistant modifies the dataset, and the dataset is split into 2 parts and I don’t know how they split it. And the method in this paper only gets ~54% acc. This post is just a try to use rust to read data and train models and realize an ML pipeline.</p>
<p>First let us import the packages we use, we should put these lines to <code>cargo.toml</code>.</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">tch</span> = <span class="string">&#x27;0.9.0&#x27;</span></span><br><span class="line"><span class="attr">anyhow</span> = <span class="string">&quot;1.0.48&quot;</span></span><br><span class="line"><span class="attr">csv</span> = <span class="string">&quot;1.1.6&quot;</span></span><br><span class="line"><span class="attr">serde</span> = &#123; version = <span class="string">&quot;1.0.147&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>] &#125;</span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.8.5&quot;</span></span><br><span class="line"><span class="attr">lazy_static</span> = <span class="string">&quot;1.4.0&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Read-data"><a href="#Read-data" class="headerlink" title="Read data"></a>Read data</h2><p>The data was in <code>csv</code> format, so we make a structure to read csv data.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CsvReader</span> &#123;</span><br><span class="line">    filepath: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">CsvReader</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(filepath: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> CsvReader &#123;</span><br><span class="line">        CsvReader &#123;</span><br><span class="line">            filepath: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(filepath),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To get data and feed it into a neural network, we should make an interface to handle these things. the first one is used to get all data in the csv file, the second one ended with ‘force’ means when an error occurs we use template value to replace the value cause some field in the dataset is null.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">ReadData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;T&gt;, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_data_force</span>(&amp;<span class="keyword">self</span>, template: T) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;T&gt;, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Implement the ReadData<T> interface, this is quite straightforward, just read data use csv crate and use serde to deserialize it into our data structure in rust.</T></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: <span class="keyword">for</span>&lt;<span class="symbol">&#x27;de</span>&gt; serde::de::Deserialize&lt;<span class="symbol">&#x27;de</span>&gt; + <span class="built_in">Clone</span>&gt; ReadData&lt;T&gt; <span class="keyword">for</span> <span class="title class_">CsvReader</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;T&gt;, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(&amp;<span class="keyword">self</span>.filepath)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Vec</span>&lt;T&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rdr</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(file);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> rdr.<span class="title function_ invoke__">deserialize</span>() &#123;</span><br><span class="line">            index += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">match</span> item &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(record) =&gt; result.<span class="title function_ invoke__">push</span>(record),</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;data &#123;:4&#125; had error and was skipped&quot;</span>, index),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_data_force</span>(&amp;<span class="keyword">self</span>, template: T) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;T&gt;, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(&amp;<span class="keyword">self</span>.filepath)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Vec</span>&lt;T&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rdr</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(file);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> rdr.<span class="title function_ invoke__">deserialize</span>() &#123;</span><br><span class="line">            index += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">match</span> item &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(record) =&gt; result.<span class="title function_ invoke__">push</span>(record),</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(_) =&gt; result.<span class="title function_ invoke__">push</span>(template.<span class="title function_ invoke__">clone</span>()),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we use a test to read data and we use <code>WineQualityData</code> to represent the data in train.csv.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[allow(non_snake_case)]</span></span><br><span class="line"><span class="meta">#[allow(non_camel_case_types)]</span></span><br><span class="line"><span class="meta">#[derive(Debug, Deserialize, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WineQualityData</span> &#123;</span><br><span class="line">    <span class="meta">#[serde(rename = <span class="string">&quot;type&quot;</span>)]</span></span><br><span class="line">    wine_type: <span class="type">String</span>,</span><br><span class="line">    <span class="meta">#[serde(rename = <span class="string">&quot;fixed acidity&quot;</span>)]</span></span><br><span class="line">    fixed_acidity: <span class="type">f64</span>,</span><br><span class="line">    <span class="meta">#[serde(rename = <span class="string">&quot;volatile acidity&quot;</span>)]</span></span><br><span class="line">    volatile_acidity: <span class="type">f64</span>,</span><br><span class="line">    <span class="meta">#[serde(rename = <span class="string">&quot;citric acid&quot;</span>)]</span></span><br><span class="line">    citric_acid: <span class="type">f64</span>,</span><br><span class="line">    <span class="meta">#[serde(rename = <span class="string">&quot;residual sugar&quot;</span>)]</span></span><br><span class="line">    residual_sugar: <span class="type">f64</span>,</span><br><span class="line">    chlorides: <span class="type">f64</span>,</span><br><span class="line">    <span class="meta">#[serde(rename = <span class="string">&quot;free sulfur dioxide&quot;</span>)]</span></span><br><span class="line">    free_sulfur_dioxide: <span class="type">f64</span>,</span><br><span class="line">    <span class="meta">#[serde(rename = <span class="string">&quot;total sulfur dioxide&quot;</span>)]</span></span><br><span class="line">    total_sulfur_dioxide: <span class="type">f64</span>,</span><br><span class="line">    density: <span class="type">f64</span>,</span><br><span class="line">    pH: <span class="type">f64</span>,</span><br><span class="line">    sulphates: <span class="type">f64</span>,</span><br><span class="line">    alcohol: <span class="type">f64</span>,</span><br><span class="line">    quality: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>the test code is following.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_read_wine_data</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reader</span> = CsvReader::<span class="title function_ invoke__">new</span>(<span class="string">&quot;./wine_dataset/train.csv&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span>: <span class="type">Vec</span>&lt;WineQualityData&gt; = reader.<span class="title function_ invoke__">get_data</span>()?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;read &#123;&#125; data&quot;</span>, data.<span class="title function_ invoke__">len</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">summary</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">data</span> <span class="keyword">in</span> data.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v</span> = data.<span class="title function_ invoke__">get_quality</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">entry</span> = summary.<span class="title function_ invoke__">entry</span>(v).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">        *entry += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">for</span> (k, v) <span class="keyword">in</span> &amp;summary &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:2&#125; - &#123;:2&#125;&quot;</span>, k, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>we run the test and it prints the data’s quality distributions</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read 3878 data</span><br><span class="line"> 6 - 1694</span><br><span class="line"> 3 - 18</span><br><span class="line"> 9 -  3</span><br><span class="line"> 7 - 643</span><br><span class="line"> 8 - 115</span><br><span class="line"> 4 - 129</span><br><span class="line"> 5 - 1276</span><br></pre></td></tr></table></figure>

<h2 id="Make-the-Tensor-to-train"><a href="#Make-the-Tensor-to-train" class="headerlink" title="Make the Tensor to train"></a>Make the Tensor to train</h2><p>The data we read from csv in the previous chapter is not Tensor struct which is required by &#96;tch-rs&#96;&#96; crate. The only input it can use is Tensor type.</p>
<p>We use a new interface <code>TrainableData</code> to make an implicit data conversation.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">TrainableData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">translate_into</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WineQualityTrainData</span> &#123;</span><br><span class="line">    inputs: <span class="type">Vec</span>&lt;<span class="type">f64</span>&gt;,</span><br><span class="line">    output: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we implement the interface for <code>WineQualityData</code>, this is also straightforward but time-consuming.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">TrainableData</span>&lt;WineQualityTrainData&gt; <span class="keyword">for</span> <span class="title class_">WineQualityData</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">translate_into</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> WineQualityTrainData &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">t</span> = <span class="keyword">match</span> <span class="keyword">self</span>.wine_type.<span class="title function_ invoke__">as_str</span>() &#123;</span><br><span class="line">            <span class="string">&quot;red&quot;</span> =&gt; <span class="number">1.0</span>,</span><br><span class="line">            _ =&gt; <span class="number">0.0</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        WineQualityTrainData &#123;</span><br><span class="line">            inputs: <span class="built_in">vec!</span>[</span><br><span class="line">                t,</span><br><span class="line">                <span class="keyword">self</span>.fixed_acidity,</span><br><span class="line">                <span class="keyword">self</span>.volatile_acidity,</span><br><span class="line">                <span class="keyword">self</span>.citric_acid,</span><br><span class="line">                <span class="keyword">self</span>.residual_sugar,</span><br><span class="line">                <span class="keyword">self</span>.chlorides,</span><br><span class="line">                <span class="keyword">self</span>.free_sulfur_dioxide,</span><br><span class="line">                <span class="keyword">self</span>.total_sulfur_dioxide,</span><br><span class="line">                <span class="keyword">self</span>.density,</span><br><span class="line">                <span class="keyword">self</span>.pH,</span><br><span class="line">                <span class="keyword">self</span>.sulphates,</span><br><span class="line">                <span class="keyword">self</span>.alcohol,</span><br><span class="line">            ],</span><br><span class="line">            output: <span class="keyword">self</span>.quality,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And also a <code>GetTensor</code> interface to make the tensor</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">GetTensor</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Tensor;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_y</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Tensor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GetTensor</span> <span class="keyword">for</span> <span class="title class_">WineQualityTrainData</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Tensor &#123;</span><br><span class="line">        Tensor::<span class="title function_ invoke__">of_slice</span>(&amp;<span class="keyword">self</span>.inputs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_y</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Tensor &#123;</span><br><span class="line">        Tensor::<span class="title function_ invoke__">of_slice</span>(&amp;(<span class="built_in">vec!</span>[<span class="keyword">self</span>.output]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Create-dataset"><a href="#Create-dataset" class="headerlink" title="Create dataset"></a>Create dataset</h2><p>In Python it’s normal to use a training dataset and test dataset to store and use data, so here we implement our own dataset, the dataset code is almost copied from the tch-rs crate mnist dataset implementation, with little modification.</p>
<p>Here we use <code>CustomDataset</code> to store all the data, and <code>CustomIter</code> to iterate the dataset, we can set <code>batch_size</code> to realize batch training.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CustomDataset</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> size: <span class="type">i32</span>,</span><br><span class="line">    <span class="keyword">pub</span> dataset: Tensor,</span><br><span class="line">    <span class="keyword">pub</span> labels: Tensor,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CustomIter</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> xs: Tensor,</span><br><span class="line">    <span class="keyword">pub</span> ys: Tensor,</span><br><span class="line">    batch_index: <span class="type">i64</span>,</span><br><span class="line">    batch_size: <span class="type">i64</span>,</span><br><span class="line">    total_size: <span class="type">i64</span>,</span><br><span class="line">    device: Device,</span><br><span class="line">    return_smaller_last_batch: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for the <code>CustomIter</code> we should implement those functions.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">CustomIter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">shuffle</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> CustomIter &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">index</span> =</span><br><span class="line">            Tensor::<span class="title function_ invoke__">randperm</span>(<span class="keyword">self</span>.total_size, (Kind::Int64, <span class="keyword">self</span>.device)).<span class="title function_ invoke__">to_device</span>(Device::Cpu);</span><br><span class="line">        <span class="keyword">self</span>.xs = <span class="keyword">self</span>.xs.<span class="title function_ invoke__">index_select</span>(<span class="number">0</span>, &amp;index);</span><br><span class="line">        <span class="keyword">self</span>.ys = <span class="keyword">self</span>.ys.<span class="title function_ invoke__">index_select</span>(<span class="number">0</span>, &amp;index);</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">size</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.total_size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">reset</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.batch_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">shuffle</span>();</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(</span><br><span class="line">        xs: &amp;Tensor,</span><br><span class="line">        ys: &amp;Tensor,</span><br><span class="line">        batch_size: <span class="type">i64</span>,</span><br><span class="line">        device: Device,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;CustomIter, TchError&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">total_size</span> = xs.<span class="title function_ invoke__">size</span>()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> ys.<span class="title function_ invoke__">size</span>()[<span class="number">0</span>] != total_size &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(TchError::<span class="title function_ invoke__">Shape</span>(<span class="built_in">format!</span>(</span><br><span class="line">                <span class="string">&quot;different dimension for the two inputs &#123;:?&#125; &#123;:?&#125;&quot;</span>,</span><br><span class="line">                xs, ys</span><br><span class="line">            )));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(CustomIter &#123;</span><br><span class="line">            xs: xs.<span class="title function_ invoke__">shallow_clone</span>(),</span><br><span class="line">            ys: ys.<span class="title function_ invoke__">shallow_clone</span>(),</span><br><span class="line">            batch_index: <span class="number">0</span>,</span><br><span class="line">            batch_size,</span><br><span class="line">            total_size,</span><br><span class="line">            device,</span><br><span class="line">            return_smaller_last_batch: <span class="literal">true</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>shuffle: rearrange the data order randomly to make the training process more reliable</p>
</li>
<li><p>size: just return the size of the dataset</p>
</li>
<li><p>reset: make the iterator return to the beginning of the dataset</p>
</li>
<li><p>new: create an iterator from the specific dataset</p>
</li>
</ol>
<p>Then we should implement the built-in <code>Iterator</code> trait for our <code>CustomIter</code> to use the for-range loop.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">CustomIter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = (Tensor, Tensor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">start</span> = <span class="keyword">self</span>.batch_index * <span class="keyword">self</span>.batch_size;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">size</span> = std::cmp::<span class="title function_ invoke__">min</span>(<span class="keyword">self</span>.batch_size, <span class="keyword">self</span>.total_size - start);</span><br><span class="line">        <span class="keyword">if</span> size &lt;= <span class="number">0</span> || (!<span class="keyword">self</span>.return_smaller_last_batch &amp;&amp; size &lt; <span class="keyword">self</span>.batch_size) &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.batch_index += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>((</span><br><span class="line">                <span class="keyword">self</span>.xs.<span class="title function_ invoke__">i</span>(start..start + size).<span class="title function_ invoke__">to_device</span>(<span class="keyword">self</span>.device),</span><br><span class="line">                <span class="keyword">self</span>.ys.<span class="title function_ invoke__">i</span>(start..start + size).<span class="title function_ invoke__">to_device</span>(<span class="keyword">self</span>.device),</span><br><span class="line">            ))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So the remaining task is to create a dataset from our conversed data.</p>
<p>Just iterate all the data read from csv file and convert it to the Tensor then stack the Tensor into one big Tensor that’s all we need.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create_dataset</span>&lt;T, E&gt;(data: <span class="type">Vec</span>&lt;T&gt;) <span class="punctuation">-&gt;</span> CustomDataset</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        T: TrainableData&lt;E&gt;,</span><br><span class="line">        E: GetTensor,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">xs</span> = <span class="type">Vec</span>::&lt;Tensor&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ys</span> = <span class="type">Vec</span>::&lt;Tensor&gt;::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> data.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">translated_item</span> = item.<span class="title function_ invoke__">translate_into</span>();</span><br><span class="line">        xs.<span class="title function_ invoke__">push</span>(translated_item.<span class="title function_ invoke__">get_x</span>());</span><br><span class="line">        ys.<span class="title function_ invoke__">push</span>(translated_item.<span class="title function_ invoke__">get_y</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dataset</span> = Tensor::<span class="title function_ invoke__">stack</span>(&amp;xs, <span class="number">0</span>).<span class="title function_ invoke__">to_kind</span>(Kind::Float);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">labels</span> = Tensor::<span class="title function_ invoke__">stack</span>(&amp;ys, <span class="number">0</span>).<span class="title function_ invoke__">to_kind</span>(Kind::Float);</span><br><span class="line">    CustomDataset &#123;</span><br><span class="line">        size,</span><br><span class="line">        dataset,</span><br><span class="line">        labels,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Train-model"><a href="#Train-model" class="headerlink" title="Train model"></a>Train model</h2><p>Now everything is fine we can play with the network model.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">LinearRegressionTrainer</span> &#123;</span><br><span class="line">    device: Device,</span><br><span class="line">    iter: <span class="type">Option</span>&lt;CustomIter&gt;,</span><br><span class="line">    test_iter: <span class="type">Option</span>&lt;CustomIter&gt;,</span><br><span class="line">    opt: <span class="type">Option</span>&lt;Optimizer&gt;,</span><br><span class="line">    <span class="keyword">pub</span> epoch: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we implement the build network function for the Trainer</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">LinearRegressionBuilder</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">LinearRegressionBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(vs: &amp;nn::Path) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Module</span> &#123;</span><br><span class="line">        nn::<span class="title function_ invoke__">seq</span>()</span><br><span class="line">            .<span class="title function_ invoke__">add</span>(nn::<span class="title function_ invoke__">linear</span>(vs, <span class="number">12</span>, <span class="number">512</span>, <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>()))</span><br><span class="line">            .<span class="title function_ invoke__">add_fn</span>(|xs| xs.<span class="title function_ invoke__">relu</span>())</span><br><span class="line">            .<span class="title function_ invoke__">add</span>(nn::<span class="title function_ invoke__">linear</span>(vs, <span class="number">512</span>, <span class="number">512</span>, <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>()))</span><br><span class="line">            .<span class="title function_ invoke__">add_fn</span>(|xs| xs.<span class="title function_ invoke__">relu</span>())</span><br><span class="line">            .<span class="title function_ invoke__">add</span>(nn::<span class="title function_ invoke__">linear</span>(vs, <span class="number">512</span>, <span class="number">512</span>, <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>()))</span><br><span class="line">            .<span class="title function_ invoke__">add_fn</span>(|xs| xs.<span class="title function_ invoke__">relu</span>())</span><br><span class="line">            .<span class="title function_ invoke__">add</span>(nn::<span class="title function_ invoke__">linear</span>(vs, <span class="number">512</span>, <span class="number">1</span>, <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>()))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Finally we can make our training function, we use <code>Adam</code> as the optimizer and <code>F1</code> Loss&#96; as our loss function, the code organized is exactly the same as pytorch, we follow the steps that in every epoch take batch from the training dataset and feed to the network model then use opt to optimize the parameters, finally use the test set(if exist) to get the result of our model.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">LinearRegressionTrainer</span>&#123;</span><br><span class="line">     <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">train</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">None</span> = <span class="keyword">self</span>.iter &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;No data&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">iter</span> = <span class="keyword">self</span>.iter.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vs</span> = nn::VarStore::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>.device);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">net</span> = LinearRegressionBuilder::<span class="title function_ invoke__">build</span>(&amp;vs.<span class="title function_ invoke__">root</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;net is ready&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">opt</span> = nn::Adam::<span class="title function_ invoke__">default</span>().<span class="title function_ invoke__">build</span>(&amp;vs, <span class="number">1e-5</span>)?;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;opt is ready&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">epoch</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="keyword">self</span>.epoch &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total_loss</span> = <span class="number">0</span> <span class="keyword">as</span> <span class="type">f64</span>;</span><br><span class="line">            iter.<span class="title function_ invoke__">reset</span>();</span><br><span class="line"></span><br><span class="line">            total_loss = <span class="number">0.0</span>;</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">&quot;epoch &#123;:4&#125;/&#123;:4&#125; is start&quot;</span>, epoch, <span class="keyword">self</span>.epoch);</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">batch</span> <span class="keyword">in</span> iter.<span class="title function_ invoke__">into_iter</span>() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">loss</span> =</span><br><span class="line">                    net.<span class="title function_ invoke__">forward</span>(&amp;batch.<span class="number">0</span>)</span><br><span class="line">                        .<span class="title function_ invoke__">f_smooth_l1_loss</span>(&amp;batch.<span class="number">1</span>, tch::Reduction::Mean, <span class="number">1.0</span>)?;</span><br><span class="line">                opt.<span class="title function_ invoke__">backward_step</span>(&amp;loss);</span><br><span class="line">                opt.<span class="title function_ invoke__">zero_grad</span>();</span><br><span class="line">                total_loss += <span class="type">f64</span>::<span class="title function_ invoke__">from</span>(&amp;loss);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">&quot; loss &#123;:4&#125;&quot;</span>, total_loss);</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(test_iter) = <span class="keyword">self</span>.test_iter.<span class="title function_ invoke__">as_mut</span>() &#123;</span><br><span class="line">                test_iter.<span class="title function_ invoke__">reset</span>();</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">total_loss</span> = <span class="number">0</span> <span class="keyword">as</span> <span class="type">f64</span>;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">batch</span> <span class="keyword">in</span> test_iter.<span class="title function_ invoke__">into_iter</span>() &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">loss</span> = net</span><br><span class="line">                        .<span class="title function_ invoke__">forward</span>(&amp;batch.<span class="number">0</span>)</span><br><span class="line">                        .<span class="title function_ invoke__">f_l1_loss</span>(&amp;batch.<span class="number">1</span>, tch::Reduction::Mean)?;</span><br><span class="line">                    total_loss += <span class="type">f64</span>::<span class="title function_ invoke__">from</span>(&amp;loss);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot; test loss &#123;:4&#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Main-func"><a href="#Main-func" class="headerlink" title="Main func"></a>Main func</h2><p>we put all the below things together and write a main function read data and train the model.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Cuda available: &#123;&#125;&quot;</span>, Cuda::<span class="title function_ invoke__">is_available</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Cudnn available: &#123;&#125;&quot;</span>, Cuda::<span class="title function_ invoke__">cudnn_is_available</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cuda_device</span> = Device::<span class="title function_ invoke__">cuda_if_available</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;App works on &#123;:?&#125;&quot;</span>, cuda_device);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reader</span> = CsvReader::<span class="title function_ invoke__">new</span>(<span class="string">&quot;./wine_dataset/train.csv&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span>: <span class="type">Vec</span>&lt;WineQualityData&gt; = reader.<span class="title function_ invoke__">get_data</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="title function_ invoke__">create_dataset</span>(data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">iter</span> = CustomIter::<span class="title function_ invoke__">new</span>(&amp;data.dataset, &amp;data.labels, *BATCHSIZE, cuda_device)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">test_data</span> = data.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">test_data</span> = <span class="title function_ invoke__">create_dataset</span>(test_data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">test_iter</span> = CustomIter::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        &amp;test_data.dataset,</span><br><span class="line">        &amp;test_data.labels,</span><br><span class="line">        test_data.size <span class="keyword">as</span> <span class="type">i64</span>,</span><br><span class="line">        cuda_device,</span><br><span class="line">    )?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;total train data &#123;&#125;&quot;</span>, iter.<span class="title function_ invoke__">size</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">train</span> = LinearRegressionTrainer::<span class="title function_ invoke__">new</span>(cuda_device);</span><br><span class="line">    train.<span class="title function_ invoke__">set_data</span>(iter);</span><br><span class="line">    train.<span class="title function_ invoke__">set_test_data</span>(test_iter);</span><br><span class="line">    train.<span class="title function_ invoke__">train</span>()?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for predict functionality, it can be implemented as same as the training process, just feed with the parameters and it will return the output, here we use the round function to make the result convert to an i32 type.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> data.<span class="title function_ invoke__">iter</span>() &#123; <span class="comment">//data is CustomDataset but use for prediction.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">item</span> = item.<span class="title function_ invoke__">translate_into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = item.<span class="title function_ invoke__">get_x</span>().<span class="title function_ invoke__">to_kind</span>(Kind::Float).<span class="title function_ invoke__">to_device</span>(<span class="keyword">self</span>.device);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = net.<span class="title function_ invoke__">forward</span>(&amp;t);</span><br><span class="line">    ans.<span class="title function_ invoke__">push</span>(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Writing to submission.csv...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">wtr</span> = csv::Writer::<span class="title function_ invoke__">from_path</span>(<span class="string">&quot;./submission.csv&quot;</span>)?;</span><br><span class="line">wtr.<span class="title function_ invoke__">write_record</span>(&amp;[<span class="string">&quot;quality&quot;</span>])?;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> ans.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">    wtr.<span class="title function_ invoke__">write_record</span>(&amp;[<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i.<span class="title function_ invoke__">double_value</span>(&amp;[<span class="number">0</span>]).<span class="title function_ invoke__">round</span>() <span class="keyword">as</span> <span class="type">i64</span>)])?;</span><br><span class="line">&#125;</span><br><span class="line">wtr.<span class="title function_ invoke__">flush</span>()?;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Writing finish&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>We have made our own simple implementation of datareader, dataset, and linear regression model with features from reading to training, from training to prediction.<br>But we should use <code>Python</code> to make prototypes and search in most cases. From the <code>tch-rs</code> github issues and other forums like Reddit, we can see various talking about rust ml, the only scenario we should use rust is the high performance and portability required, not the training process and data handling.</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Ocaml Tree,  An Intuitive Tutorial</title>
    <url>/posts/4080/</url>
    <content><![CDATA[<h1 id="Ocaml-Tree-An-Intuitive-Tutorial"><a href="#Ocaml-Tree-An-Intuitive-Tutorial" class="headerlink" title="Ocaml Tree, An Intuitive Tutorial"></a>Ocaml Tree, An Intuitive Tutorial</h1><p>该文章主要描述了一些简单的树型数据结构。</p>
<h2 id="基本树"><a href="#基本树" class="headerlink" title="基本树"></a>基本树</h2><p>树形结构是一种非线性数据结构，在计算机科学领域有非常多的用途，一棵树由<strong>根</strong>和<strong>孩子</strong>组成，树是递归定义的，我们可以将树定义为一个<strong>type</strong>，他可以是空结点，也可以是一个非空结点，非空结点会有左、右两颗子树和值，我们可以将树定义为这样的结构。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="symbol">&#x27;a</span> tree = <span class="type">Empty</span> | <span class="type">Node</span> <span class="keyword">of</span> <span class="symbol">&#x27;a</span> * <span class="symbol">&#x27;a</span> tree * <span class="symbol">&#x27;a</span> tree</span><br></pre></td></tr></table></figure>

<p>如构造一颗这样的树，我们就可以采用这样的方式。</p>
<img src="/posts/4080/image-20210104215359261.png" alt="image-20210104215359261" style="zoom:50%;">

<p>该树的变量声明</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = <span class="type">Node</span>(<span class="number">1</span>, <span class="type">Node</span>(<span class="number">5</span>, <span class="type">Node</span>(<span class="number">4</span>, <span class="type">Empty</span>, <span class="type">Empty</span>),<span class="type">Node</span> (<span class="number">2</span>, <span class="type">Empty</span>, <span class="type">Empty</span>)), <span class="type">Node</span>(<span class="number">3</span>, <span class="type">Node</span>(<span class="number">10</span>,<span class="type">Empty</span>,<span class="type">Node</span>(<span class="number">17</span>,<span class="type">Empty</span>,<span class="type">Empty</span>)), <span class="type">Node</span>(<span class="number">14</span>,<span class="type">Empty</span>,<span class="type">Empty</span>)));;</span><br></pre></td></tr></table></figure>

<p>获取树的大小函数</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> size = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="number">0</span></span><br><span class="line">  | <span class="type">Node</span>(_, left, right) -&gt; <span class="number">1</span> + size left + size right;;</span><br></pre></td></tr></table></figure>

<p>先序、中序、后序遍历函数</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> preOrder = <span class="keyword">function</span></span><br><span class="line">| <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">| <span class="type">Node</span>(v,l,r) -&gt; <span class="type">Printf</span>.printf<span class="string">&quot;%d &quot;</span>  v ; preOrder(l) ; preOrder(r);;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> midOrder = <span class="keyword">function</span></span><br><span class="line">| <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">| <span class="type">Node</span>(v,l,r) -&gt; midOrder(l) ; <span class="type">Printf</span>.printf<span class="string">&quot;%d &quot;</span>  v ; midOrder(r);;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> postOrder = <span class="keyword">function</span></span><br><span class="line">| <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">| <span class="type">Node</span>(v,l,r) -&gt; postOrder(l) ; postOrder(r); <span class="type">Printf</span>.printf<span class="string">&quot;%d &quot;</span>  v ;;</span><br></pre></td></tr></table></figure>

<p>测试上述基本函数</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="type">Printf</span>.printf <span class="string">&quot;树的大小为%d\n&quot;</span>  (size(node));</span><br><span class="line">printf <span class="string">&quot;先序遍历\n&quot;</span>;</span><br><span class="line">preOrder node;</span><br><span class="line">printf <span class="string">&quot;\n中序遍历\n&quot;</span>;</span><br><span class="line">midOrder node;</span><br><span class="line">printf <span class="string">&quot;\n后序遍历\n&quot;</span>;</span><br><span class="line">postOrder node;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">树的大小为8</span><br><span class="line">先序遍历</span><br><span class="line">1 5 4 2 3 10 17 14</span><br><span class="line">中序遍历</span><br><span class="line">4 5 2 1 10 17 3 14</span><br><span class="line">后序遍历</span><br><span class="line">4 2 5 17 10 14 3 1</span><br></pre></td></tr></table></figure>

<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>在有了基本的树结构之后，我们考虑构建二叉查找树，二叉查找树在插入结点时，将比当前结点大的结点插到右子树，否则插入到左子树，如果按照 3-1-5-2-4-17-14-10 的顺序插入，会构建如下的二叉查找树。</p>
<img src="/posts/4080/image-20210104221045493.png" alt="image-20210104221045493" style="zoom:50%;">

<p>为了构建这样一颗二叉树，同时加上纯函数式的限制，我们每次插入结点时都会建造一颗新的二叉树。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> insert tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="type">Node</span> (<span class="keyword">value</span>, <span class="type">Empty</span>, <span class="type">Empty</span>)</span><br><span class="line">  | <span class="type">Node</span> (v, left, right) -&gt;</span><br><span class="line">      <span class="keyword">if</span> v = <span class="keyword">value</span> <span class="keyword">then</span> tree</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">value</span> &gt; v <span class="keyword">then</span> <span class="type">Node</span> (v, insert left <span class="keyword">value</span>, right)</span><br><span class="line">      <span class="keyword">else</span> <span class="type">Node</span> (v, left, insert right <span class="keyword">value</span>)</span><br></pre></td></tr></table></figure>

<p>函数解释</p>
<ul>
<li><p>该函数是二叉排序树的插入函数，插入数值已存在时不产生任何动作，直接返回该结点</p>
</li>
<li><p>插入数值小于当前结点 当前数值不变，右子树不变，那么就需要把这个值插入到左子树</p>
</li>
<li><p>插入数值大于当前结点 当前数字不变，左子树不变，那么就需要把这个值插入到右子树</p>
</li>
<li><p>如果碰到了空结点，那么就代表寻找到了合适的插入位置，将其插入并且返回 Node</p>
</li>
</ul>
<p>函数测试</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* 3-1-5-2-4-17-14-10 *)</span></span><br><span class="line"><span class="keyword">let</span> node = insert <span class="type">Empty</span> <span class="number">3</span>;;</span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">1</span>;;</span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">5</span>;;</span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">2</span>;;</span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">4</span>;;</span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">17</span>;;</span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">14</span>;;</span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">10</span>;;</span><br><span class="line"></span><br><span class="line">printf <span class="string">&quot;\n二叉排序树中序遍历\n&quot;</span>;</span><br><span class="line">midOrder node;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">二叉排序树中序遍历</span><br><span class="line">1 2 3 4 5 10 14 17</span><br></pre></td></tr></table></figure>

<p>结构验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">utop <span class="comment"># node;;</span></span><br><span class="line">- : int tree =</span><br><span class="line">Node (3, Node (1, Empty, Node (2, Empty, Empty)),</span><br><span class="line"> Node (5, Node (4, Empty, Empty),</span><br><span class="line">  Node (17, Node (14, Node (10, Empty, Empty), Empty), Empty)))</span><br></pre></td></tr></table></figure>

<p>对于二叉树排序树，有用的不仅仅是插入，还有查询和删除</p>
<p>查询函数</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> query tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">false</span></span><br><span class="line">  | <span class="type">Node</span>(v,l,r) -&gt; v = <span class="keyword">value</span> || query l <span class="keyword">value</span> || query r <span class="keyword">value</span> ;;</span><br></pre></td></tr></table></figure>

<p>验证正确性</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> printBool = <span class="keyword">function</span></span><br><span class="line">| <span class="literal">true</span> -&gt; printf<span class="string">&quot;结果为真\n&quot;</span>;</span><br><span class="line">| <span class="literal">false</span> -&gt; printf<span class="string">&quot;结果为假\n&quot;</span>;;</span><br><span class="line"></span><br><span class="line">print_endline(<span class="string">&quot;&quot;</span>);</span><br><span class="line">printBool (query node <span class="number">10</span>); <span class="comment">(* should be true *)</span></span><br><span class="line">printBool (query node <span class="number">11</span>); <span class="comment">(* should be false *)</span></span><br></pre></td></tr></table></figure>

<p>删除函数</p>
<p>对于二叉排序树的删除，我们分三种情况</p>
<ol>
<li>叶子结点，直接删除即可</li>
<li>只有单一的孩子，将这个孩子结点与其父结点相连</li>
<li>有左右孩子，寻找左子树最大结点$r$，覆盖该结点，此时删除直接完成</li>
</ol>
<p>对应图例</p>
<ul>
<li><p>情况 1，删除结点 2，2 直接移除连线</p>
<img src="/posts/4080/image-20210105004203912.png" alt="image-20210105004203912" style="zoom:33%;">
</li>
<li><p>情况 2 删除结点 14，10 与 17 直接相连</p>
<img src="/posts/4080/image-20210105004251316.png" alt="image-20210105004251316" style="zoom:33%;">
</li>
<li><p>情况 3 删除结点 3，2 替换 3 的位置</p>
<img src="/posts/4080/image-20210105004503695.png" alt="image-20210105004503695" style="zoom:33%;"></li>
</ul>
<p>综上所述，我们可以得出下述的算法</p>
<ol>
<li>如果该结点是叶子结点，直接返回<strong>Empty</strong>，删除完毕。</li>
<li>如果该结点是单孩子结点，直接返回他的<strong>孩子结点</strong>。</li>
<li>如果该结点有左右子树，把最左子树的最右子树替换到被删除结点，同时被删除结点的上一个结点的右子树修改为空，对于函数式语言来说，显然我们要做的是两步骤，在被删除结点修改当前值$v$，以及最左子树的最右子树，返回一个<strong>Empty</strong>和一个$v’$，所以我们这边需要一个新的函数去寻找左子树的最右子树</li>
</ol>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* 删除二叉排序树 *)</span></span><br><span class="line"><span class="comment">(* Thanks for the reference https://codereview.stackexchange.com/questions/187716/deleting-a-node-from-binary-tree-in-ocaml *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> mostRight = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; failwith <span class="string">&quot;结点存在一些问题&quot;</span></span><br><span class="line">  | <span class="type">Node</span> (v, _, <span class="type">Empty</span>) -&gt; v</span><br><span class="line">  | <span class="type">Node</span> (_, _, r) -&gt; mostRight r</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> delete tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="type">Empty</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) <span class="keyword">when</span> v &lt; <span class="keyword">value</span> -&gt; <span class="type">Node</span> (v, l, delete r <span class="keyword">value</span>)</span><br><span class="line">  | <span class="type">Node</span> (v, l, r) <span class="keyword">when</span> v &gt; <span class="keyword">value</span> -&gt; <span class="type">Node</span> (v, delete l <span class="keyword">value</span>, r)</span><br><span class="line">  | <span class="type">Node</span> (v, <span class="type">Empty</span>, <span class="type">Empty</span>) -&gt; <span class="type">Empty</span> <span class="comment">(* 直接删除自己 对应情况1 *)</span></span><br><span class="line">  | <span class="type">Node</span> (v, <span class="type">Empty</span>, r) -&gt; r <span class="comment">(* 情况2 删除自己 连接右子树 *)</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, <span class="type">Empty</span>) -&gt; l <span class="comment">(* 情况2 删除自己 连接左子树 *)</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) -&gt; <span class="comment">(* 情况3，替换自己，删除原来的值 *)</span></span><br><span class="line">      <span class="keyword">let</span> newValue = mostRight l <span class="keyword">in</span></span><br><span class="line">      <span class="type">Node</span> (newValue, delete l newValue, r)</span><br></pre></td></tr></table></figure>

<p>以及对应的测试</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* 测试删除 *)</span></span><br><span class="line"><span class="keyword">let</span> delete2 = delete node <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> delete14 = delete node <span class="number">14</span></span><br><span class="line"><span class="keyword">let</span> delete3 = delete node <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val delete : &#x27;a tree -&gt; &#x27;a -&gt; &#x27;a tree = &lt;fun&gt;</span><br><span class="line">val delete2 : int tree =</span><br><span class="line">  Node (3, Node (1, Empty, Empty),</span><br><span class="line">   Node (5, Node (4, Empty, Empty),</span><br><span class="line">    Node (17, Node (14, Node (10, Empty, Empty), Empty), Empty)))</span><br><span class="line">val delete14 : int tree =</span><br><span class="line">  Node (3, Node (1, Empty, Node (2, Empty, Empty)),</span><br><span class="line">   Node (5, Node (4, Empty, Empty),</span><br><span class="line">    Node (17, Node (10, Empty, Empty), Empty)))</span><br><span class="line">val delete3 : int tree =</span><br><span class="line">  Node (2, Node (1, Empty, Empty),</span><br><span class="line">   Node (5, Node (4, Empty, Empty),</span><br><span class="line">    Node (17, Node (14, Node (10, Empty, Empty), Empty), Empty)))</span><br></pre></td></tr></table></figure>

<p>可以看见确实成功的变成了我们图示的样子。</p>
<h2 id="自平衡二叉树"><a href="#自平衡二叉树" class="headerlink" title="自平衡二叉树"></a>自平衡二叉树</h2><p>在一棵高度平衡的二叉排序树中，我们几乎可以以$\log n$的时间开销去寻找元素，但是考虑特殊构造的数据$1,2,3..n$，就会让二叉排序树退化成一个线性链表，这显然是我们无法接受的，我们给结点定义一个<strong>平衡因子</strong>，表示左右子树的深度之差， 一般将其分为四种情况考虑，用$L$表示左子树不平衡，$R$表示右子树不平衡，一共有四种情况。</p>
<p>请注意这些序号并不表示数据本身的大小，只是一个逻辑关系。</p>
<h3 id="RR-数字不代表数值关系"><a href="#RR-数字不代表数值关系" class="headerlink" title="RR(数字不代表数值关系)"></a>RR(数字不代表数值关系)</h3><img src="/posts/4080/image-20210107195155968.png" alt="image-20210107195155968" style="zoom:50%;">

<p>这样的树我们可以我们可以在子树<strong>3</strong>处做一次左旋操作，使得树变成平衡状态，具体操作是<strong>1</strong>旋转下去，同时原先<strong>4</strong>的位置被<strong>1</strong>接管，那么显然<strong>3</strong>的原左子树将成为<strong>1</strong>的右子树，这样完成了一次左旋操作，如果你不能理解这个过程，请务必亲手尝试一下，并结合下面的代码阅读，所谓左旋也并非只是向左旋转，请不要将重心过度放在左旋这个动作本身的语义上。</p>
<img src="/posts/4080/image-20210107195704276.png" alt="image-20210107195704276" style="zoom:50%;">

<h3 id="LL-数字不代表数值关系"><a href="#LL-数字不代表数值关系" class="headerlink" title="LL(数字不代表数值关系)"></a>LL(数字不代表数值关系)</h3><img src="/posts/4080/image-20210108194827058.png" alt="image-20210108194827058" style="zoom:50%;">

<p>这种情况和<strong>RR</strong>型真好相反，我们对<strong>2</strong>做一次右旋操作就可以达成目的，具体可以查看旋转后的图片自行想象。</p>
<img src="/posts/4080/image-20210108195004831.png" alt="image-20210108195004831" style="zoom:50%;">

<h3 id="RL-数字不代表数值关系"><a href="#RL-数字不代表数值关系" class="headerlink" title="RL(数字不代表数值关系)"></a>RL(数字不代表数值关系)</h3><img src="/posts/4080/image-20210108195751154.png" alt="image-20210108195751154" style="zoom:50%;">

<p>这种情况通过一次<strong>L</strong>旋转或者<strong>R</strong>旋转都无法使得二叉树平衡，对应的，我们需要进行一次<strong>右旋</strong>再进行一次<strong>左旋</strong>，具体的流程图如下</p>
<p>首先进行一次<strong>右旋</strong>，注意目标是失去平衡结点的右子树。</p>
<img src="/posts/4080/image-20210108201735637.png" alt="image-20210108201735637" style="zoom:50%;">

<p>然后此时变成了<strong>RR</strong>型结点，在进行一次<strong>左旋</strong>。</p>
<img src="/posts/4080/image-20210108202110208.png" alt="image-20210108202110208" style="zoom:50%;">

<h3 id="LR-数字代表数值关系"><a href="#LR-数字代表数值关系" class="headerlink" title="LR(数字代表数值关系)"></a>LR(数字代表数值关系)</h3><p>此次采用了真实数据，数据大小即代表真实的结点情况</p>
<img src="/posts/4080/image-20210108202315145.png" alt="image-20210108202315145" style="zoom:50%;">

<p>首先进行<strong>左旋</strong></p>
<img src="/posts/4080/image-20210108203207681.png" alt="image-20210108203207681" style="zoom:50%;">

<p>再进行一次<strong>右旋</strong></p>
<img src="/posts/4080/image-20210108203346920.png" alt="image-20210108203346920" style="zoom:50%;">

<p>对于这种数据结构，我们的核心就是两种操作，左旋、右旋。</p>
<p>这边是一年前的数据结构课设的 C 语言 AVL 树代码，通过下面的代码，希望能够给你一个更加直观地、大致上的我们印象，让你要知道如何操作 AVL 树来使它达成平衡的目的。</p>
<h3 id="左右旋"><a href="#左右旋" class="headerlink" title="左右旋"></a>左右旋</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node *<span class="title function_">rightRotation</span><span class="params">(node *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//右旋 left提到root位置，root下去，同时root接管left的右儿子（root左儿子）</span></span><br><span class="line">    node *tmp = root-&gt;leftSon;</span><br><span class="line">    root-&gt;leftSon = tmp-&gt;rightSon;</span><br><span class="line">    tmp-&gt;rightSon = root;</span><br><span class="line">    getTreeHeight(tmp);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node *<span class="title function_">leftRotation</span><span class="params">(node *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//左旋 right提到root位置，root下去，root接管left的左儿子 （root右儿子）</span></span><br><span class="line">    node *tmp = root-&gt;rightSon;</span><br><span class="line">    root-&gt;rightSon = tmp-&gt;leftSon;</span><br><span class="line">    tmp-&gt;leftSon = root;</span><br><span class="line">    getTreeHeight(tmp); <span class="comment">//新跟节点重新判深度</span></span><br><span class="line">    <span class="keyword">return</span> tmp;         <span class="comment">//新结点 是否要用于下一步旋转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###二叉树的重新平衡</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node *<span class="title function_">rebalance</span><span class="params">(node *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> balance = getTreeBalance(root);</span><br><span class="line">    <span class="comment">// printf(&quot;balance = %d\n&quot;, balance);</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//L? 操作</span></span><br><span class="line">        <span class="keyword">if</span> (getTreeBalance(root-&gt;leftSon) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//LL 对应左子树更多</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;LL\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> rightRotation(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//LR 对应右子树更多</span></span><br><span class="line">            <span class="comment">//下级L 这级R</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;LR\n&quot;</span>);</span><br><span class="line">            root-&gt;leftSon = leftRotation(root-&gt;leftSon);</span><br><span class="line">            <span class="keyword">return</span> rightRotation(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//R? 操作</span></span><br><span class="line">        <span class="keyword">if</span> (getTreeBalance(root-&gt;rightSon) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//RR 对应右子树更多</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;RR\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> leftRotation(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//RL</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;RL\n&quot;</span>);</span><br><span class="line">            root-&gt;rightSon = rightRotation(root-&gt;rightSon);</span><br><span class="line">            <span class="keyword">return</span> leftRotation(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写二叉树辅助输出函数"><a href="#编写二叉树辅助输出函数" class="headerlink" title="编写二叉树辅助输出函数"></a>编写二叉树辅助输出函数</h3><p>一个求幂的函数</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> pow base power = <span class="keyword">if</span> power = <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> base * pow base (power - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>对应函数的尾递归版本，尾递归版本拥有更快的速度和更少的内存占用，非常值得提倡</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pow_tr base power =</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> _pow_tr base power sum =</span><br><span class="line">    <span class="keyword">if</span> power = <span class="number">0</span> <span class="keyword">then</span> sum <span class="keyword">else</span> _pow_tr base (power - <span class="number">1</span>) (base * sum) <span class="keyword">in</span></span><br><span class="line">  _pow_tr base power <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>访问<a href="https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/data/tail_recursion.html">Link</a>学习更多有关尾递归的知识</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>首先需要一个新的构造子，之前的构造子并不包含有关深度的信息，对于自平衡二叉树来说，我们还需要关注到他树的深度。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="symbol">&#x27;a</span> avlTree = <span class="type">Empty</span> | <span class="type">Node</span> <span class="keyword">of</span> <span class="symbol">&#x27;a</span> * <span class="symbol">&#x27;a</span> avlTree * <span class="symbol">&#x27;a</span> avlTree * <span class="built_in">int</span></span><br></pre></td></tr></table></figure>

<h4 id="左旋和右旋"><a href="#左旋和右旋" class="headerlink" title="左旋和右旋"></a>左旋和右旋</h4><p>我们在 Ocaml 中能够使用一种更加优雅的方式去处理，模式匹配可以直接把我们需要的两个受到影响的点取出来建造新的结点，代码会变得异常的短。<br><strong>左旋</strong>就是重新生成了一个结点，将该结点的数值变成了右子树的数值，将左子树变为了一个新建的结点，这个过程和前面的描述是一样的，该步骤完成之后整一个旋转过程就直接完成了，剩余的东西我们无需再去管理，和<strong>C 语言</strong>版本对比，因为我们不需要去处理指针的指向，我们将所有的结点都视作 avlTree 的构造子类型，就可以通过不断构造去新建受影响的结点，不需要向 C 语言一样去修改不同点之间的逻辑关系。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* 辅助生成结点的函数 因为要动态控制树的高度 *)</span></span><br><span class="line"><span class="keyword">let</span> makeNode <span class="keyword">value</span> leftTree rightTree =</span><br><span class="line">  <span class="type">Node</span></span><br><span class="line">    ( <span class="keyword">value</span></span><br><span class="line">    , leftTree</span><br><span class="line">    , rightTree</span><br><span class="line">    , <span class="number">1</span> + max (avlHeight leftTree) (avlHeight rightTree) )</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> avlHeight = <span class="keyword">function</span> <span class="type">Empty</span> -&gt; <span class="number">0</span> | <span class="type">Node</span> (_, _, _, h) -&gt; h</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 左旋 *)</span></span><br><span class="line"><span class="keyword">let</span> rotateLeft = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, <span class="type">Node</span> (_v, _l, _r, _), _) -&gt; makeNode _v (makeNode v l _l) _r</span><br><span class="line">  | _ -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* 右旋 *)</span></span><br><span class="line"><span class="keyword">let</span> rotateRight = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Node</span> (v, <span class="type">Node</span> (_v, _l, _r, _), r, _) -&gt; makeNode _v _l (makeNode v _r r)</span><br><span class="line">  | _ -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="LR-情况判断-以及-左右旋转"><a href="#LR-情况判断-以及-左右旋转" class="headerlink" title="LR 情况判断 以及 左右旋转"></a>LR 情况判断 以及 左右旋转</h4><p>我们利用之前的函数就可以完成 LR 情况的判断，具体的判断流程是如果该结点为<strong>Empty</strong>结点，我们可以直接插入该结点，否则的话就需要递归插入这个结点，根据插入之后的情况来判断是否需要左右旋转，</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> insert tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="type">Node</span> (<span class="keyword">value</span>, <span class="type">Empty</span>, <span class="type">Empty</span>, <span class="number">1</span>)</span><br><span class="line">  | <span class="type">Node</span> (v, l, r, _) -&gt; (</span><br><span class="line">      <span class="keyword">if</span> v = <span class="keyword">value</span> <span class="keyword">then</span> tree</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">value</span> &lt; v <span class="keyword">then</span></span><br><span class="line">        <span class="comment">(* 如何判断插入之后是否需要左右旋转  我们需要插入后的树的高度 *)</span></span><br><span class="line">        <span class="keyword">match</span> insert l <span class="keyword">value</span> <span class="keyword">with</span></span><br><span class="line">        | <span class="type">Empty</span> -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br><span class="line">        | <span class="type">Node</span> (_v, _l, _r, _h) <span class="keyword">as</span> _node -&gt;</span><br><span class="line">            <span class="keyword">if</span> _h - avlHeight r &lt;= <span class="number">1</span> <span class="keyword">then</span> makeNode v _node r</span><br><span class="line">              <span class="comment">(* 直接插入这个结点不需要旋转 *)</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">let</span> _node =</span><br><span class="line">                <span class="comment">(* 根据前面的描述判断是否需要多旋转一次 *)</span></span><br><span class="line">                <span class="keyword">if</span> avlHeight _l &lt; avlHeight _r <span class="keyword">then</span> rotateLeft _node <span class="keyword">else</span> _node</span><br><span class="line">              <span class="keyword">in</span></span><br><span class="line">              rotateRight (makeNode v _node r) <span class="comment">(* L? 情况通用的右旋 *)</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">match</span> insert r <span class="keyword">value</span> <span class="keyword">with</span></span><br><span class="line">        | <span class="type">Empty</span> -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br><span class="line">        | <span class="type">Node</span> (_v, _l, _r, _h) <span class="keyword">as</span> _node -&gt;</span><br><span class="line">            <span class="keyword">if</span> _h - avlHeight l &lt;= <span class="number">1</span> <span class="keyword">then</span> makeNode v l _node</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">let</span> _node =</span><br><span class="line">                <span class="keyword">if</span> avlHeight _l &gt; avlHeight _r <span class="keyword">then</span> rotateRight _node <span class="keyword">else</span> _node</span><br><span class="line">              <span class="keyword">in</span></span><br><span class="line">              rotateLeft (makeNode v l _node) )</span><br></pre></td></tr></table></figure>

<h3 id="插入测试"><a href="#插入测试" class="headerlink" title="插入测试"></a>插入测试</h3><p>####RR</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> avlNode = insert <span class="type">Empty</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">30</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">40</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val avlNode : int avlTree = Node (10, Empty, Empty, 1)</span><br><span class="line">val avlNode : int avlTree = Node (10, Empty, Node (20, Empty, Empty, 1), 2)</span><br><span class="line">val avlNode : int avlTree =</span><br><span class="line">  Node (20, Node (10, Empty, Empty, 1), Node (30, Empty, Empty, 1), 2)</span><br><span class="line">val avlNode : int avlTree =</span><br><span class="line">  Node (20, Node (10, Empty, Empty, 1),</span><br><span class="line">   Node (30, Empty, Node (40, Empty, Empty, 1), 2), 3)</span><br></pre></td></tr></table></figure>

<center>旋转过程</center>

<img src="/posts/4080/image-20210108185953543.png" alt="image-20210108185953543" style="zoom:50%;">

<img src="/posts/4080/image-20210108184007479.png" alt="image-20210108184007479" style="zoom:50%;">

<img src="/posts/4080/image-20210108184234026.png" alt="image-20210108184234026" style="zoom:50%;">

<img src="/posts/4080/image-20210108185746717.png" alt="image-20210108185746717" style="zoom:50%;">

<h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p>分别插入<code>40 30 20 10</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val avlNode : int avlTree = Node (40, Empty, Empty, 1)</span><br><span class="line">val avlNode : int avlTree = Node (40, Node (30, Empty, Empty, 1), Empty, 2)</span><br><span class="line">val avlNode : int avlTree =</span><br><span class="line">  Node (30, Node (20, Empty, Empty, 1), Node (40, Empty, Empty, 1), 2)</span><br><span class="line">val avlNode : int avlTree =</span><br><span class="line">  Node (30, Node (20, Node (10, Empty, Empty, 1), Empty, 2),</span><br><span class="line">   Node (40, Empty, Empty, 1), 3)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    30</span><br><span class="line">   /  \</span><br><span class="line">  20  40</span><br><span class="line"> /</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>验证正确</p>
<h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p>分别插入<code>30 10 20</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val avlNode : int avlTree = Node (30, Empty, Empty, 1)</span><br><span class="line">val avlNode : int avlTree = Node (30, Node (10, Empty, Empty, 1), Empty, 2)</span><br><span class="line">val avlNode : int avlTree = Node (20, Node (10, Empty, Empty, 1), Node (30, Empty, Empty, 1), 2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  20</span><br><span class="line"> /  \</span><br><span class="line">10  30</span><br></pre></td></tr></table></figure>

<p>验证正确</p>
<h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p>分别插入<code>10 30 20</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val avlNode : int avlTree = Node (10, Empty, Empty, 1)</span><br><span class="line">val avlNode : int avlTree = Node (10, Empty, Node (30, Empty, Empty, 1), 2)</span><br><span class="line">val avlNode : int avlTree = Node (20, Node (10, Empty, Empty, 1), Node (30, Empty, Empty, 1), 2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  20</span><br><span class="line"> /  \</span><br><span class="line">10  30</span><br></pre></td></tr></table></figure>

<p>验证正确</p>
<h4 id="插入较多的数字"><a href="#插入较多的数字" class="headerlink" title="插入较多的数字"></a>插入较多的数字</h4><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> avlNode = insert <span class="type">Empty</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">30</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">25</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">34</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">37</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">39</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">22</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">16</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">13</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">7</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val avlNode : int avlTree =</span><br><span class="line">  Node (20,</span><br><span class="line">   Node (13,</span><br><span class="line">    Node (7, Node (3, Empty, Empty, 1), Node (10, Empty, Empty, 1), 2),</span><br><span class="line">    Node (16, Empty, Empty, 1), 3),</span><br><span class="line">   Node (30, Node (25, Node (22, Empty, Empty, 1), Empty, 2),</span><br><span class="line">    Node (37, Node (34, Empty, Empty, 1), Node (39, Empty, Empty, 1), 2), 3),</span><br><span class="line">   4)</span><br></pre></td></tr></table></figure>

<p>结果图示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         20</span><br><span class="line">     /--- ---\</span><br><span class="line">    13        30</span><br><span class="line">   /  \      /  \</span><br><span class="line">  7   16    25  37</span><br><span class="line"> / \       /   /  \</span><br><span class="line">3  10     22  34  39</span><br></pre></td></tr></table></figure>

<p>应该没有太多的问题</p>
<h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><p>删除结点的过程和 BST 删除类似，唯一的区别是删除完之后需要重新调整平衡，有可能删除完之后会造成树失去平衡，步骤和<strong>insert</strong>差不多，请自行思考，如果思考不了看 C 语言版本。</p>
<h4 id="排序数据输出-中序遍历"><a href="#排序数据输出-中序遍历" class="headerlink" title="排序数据输出(中序遍历)"></a>排序数据输出(中序遍历)</h4><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> avlMidOrder = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r, _) -&gt; avlMidOrder l ; printf <span class="string">&quot;%d &quot;</span> v ; avlMidOrder r</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 7 10 13 16 20 22 25 30 34 37 39</span><br></pre></td></tr></table></figure>

<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>哈夫曼树是哈夫曼编码的一种求解方式，我们可以利用这种数据结构给数据进行一种编码，原则就是出现次数多的字符使用更短的编码，次数少的字符使用更长的编码，可以采用堆这一个数据结构求解该编码，翻出去年的数据结构课设希望能够有一种直观的理解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">CoreType::node *<span class="title">getHuffmanTreeByCntArray</span><span class="params">(vector&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; &amp;frequencyArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> CoreType::node;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span> <span class="comment">//functor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> node *a, <span class="type">const</span> node *b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;weight &gt;= b-&gt;weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue&lt;node *, vector&lt;node *&gt;, cmp&gt; assistHeap;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [ch, cnt] : frequencyArray)</span><br><span class="line">    &#123;</span><br><span class="line">        node *tmpNode = <span class="keyword">new</span> node&#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, cnt, <span class="built_in">int</span>(ch)&#125;;</span><br><span class="line">        assistHeap.<span class="built_in">push</span>(tmpNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (assistHeap.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node *firstNode = assistHeap.<span class="built_in">top</span>();</span><br><span class="line">        assistHeap.<span class="built_in">pop</span>();</span><br><span class="line">        node *secondNode = assistHeap.<span class="built_in">top</span>();</span><br><span class="line">        assistHeap.<span class="built_in">pop</span>();</span><br><span class="line">        node *newNode = <span class="keyword">new</span> node&#123;firstNode, secondNode, firstNode-&gt;weight + secondNode-&gt;weight, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;Combine &quot; &lt;&lt; firstNode-&gt;weight &lt;&lt; &quot; With &quot; &lt;&lt; secondNode-&gt;weight &lt;&lt; endl;</span></span><br><span class="line">        assistHeap.<span class="built_in">push</span>(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assistHeap.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试给定哈夫曼树结点能否生成编码</strong></p>
<p>构造如图所示的哈夫曼树，下面表示应该的编码方式</p>
 <img src="/posts/4080/image-20210108214635693.png" alt="image-20210108214635693" style="zoom:50%;">

<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nodell = <span class="type">HuffmanNode</span> &#123;data= <span class="type">Some</span> <span class="string">&#x27;a&#x27;</span>; count= <span class="number">0</span>; left= <span class="type">Empty</span>; right= <span class="type">Empty</span>&#125;</span><br><span class="line"><span class="keyword">let</span> nodelr = <span class="type">HuffmanNode</span> &#123;data= <span class="type">Some</span> <span class="string">&#x27;c&#x27;</span>; count= <span class="number">0</span>; left= <span class="type">Empty</span>; right= <span class="type">Empty</span>&#125;</span><br><span class="line"><span class="keyword">let</span> noderl = <span class="type">HuffmanNode</span> &#123;data= <span class="type">Some</span> <span class="string">&#x27;b&#x27;</span>; count= <span class="number">0</span>; left= <span class="type">Empty</span>; right= <span class="type">Empty</span>&#125;</span><br><span class="line"><span class="keyword">let</span> noderr = <span class="type">HuffmanNode</span> &#123;data= <span class="type">Some</span> <span class="string">&#x27;d&#x27;</span>; count= <span class="number">0</span>; left= <span class="type">Empty</span>; right= <span class="type">Empty</span>&#125;</span><br><span class="line"><span class="keyword">let</span> nodel = <span class="type">HuffmanNode</span> &#123;data= <span class="type">None</span>; count= <span class="number">0</span>; left= nodell; right= nodelr&#125;</span><br><span class="line"><span class="keyword">let</span> noder = <span class="type">HuffmanNode</span> &#123;data= <span class="type">None</span>; count= <span class="number">0</span>; left= noderl; right= noderr&#125;</span><br><span class="line"><span class="keyword">let</span> testNode = <span class="type">HuffmanNode</span> &#123;data= <span class="type">None</span>; count= <span class="number">0</span>; left= nodel; right= noder&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义哈夫曼树的数据结构"><a href="#定义哈夫曼树的数据结构" class="headerlink" title="定义哈夫曼树的数据结构"></a>定义哈夫曼树的数据结构</h3><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> optional_char = <span class="type">Some</span> <span class="keyword">of</span> <span class="built_in">char</span> | <span class="type">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> huffmanTree = <span class="type">Empty</span> | <span class="type">HuffmanNode</span> <span class="keyword">of</span> huffmanNode</span><br><span class="line"><span class="keyword">and</span> huffmanNode =</span><br><span class="line">  &#123;data: optional_char * <span class="built_in">int</span>; count: <span class="built_in">int</span>; left: huffmanTree; right: huffmanTree&#125;</span><br></pre></td></tr></table></figure>

<p>我们的<strong>哈夫曼</strong>树也是一颗树，但他会额外拥有一个<code>count</code>属性来表明当前这个结点的计算次数，同时他的数据是<strong>可选</strong>类型，因为从上文的哈夫曼树例子我们可以看出，只有叶子结点会挂载数据。</p>
<p>我们实现哈夫曼的过程本质上就是优先队列上不断取出和合并的过程，因此我们需要再做一个优先队列，优先队列可以做成模块，通过函子(functor)去初始化模块，增加泛型开发的能力。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">type</span> <span class="type">Comparable</span> = <span class="keyword">sig</span></span><br><span class="line">  <span class="keyword">type</span> t</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> compare : t -&gt; t -&gt; <span class="built_in">int</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="type">Make_priority_queue</span> (<span class="type">QueueNode</span> : <span class="type">Comparable</span>) = <span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">let</span> top = <span class="keyword">function</span></span><br><span class="line">    | hd :: tl -&gt; hd</span><br><span class="line">    | <span class="literal">[]</span> -&gt; failwith <span class="string">&quot;没有更多结点了 Error on top&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pop = <span class="keyword">function</span></span><br><span class="line">    | hd :: tl -&gt; tl</span><br><span class="line">    | <span class="literal">[]</span> -&gt; failwith <span class="string">&quot;没有更多结点了 Error on pop&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> push queue <span class="keyword">value</span> =</span><br><span class="line">    <span class="keyword">match</span> queue <span class="keyword">with</span></span><br><span class="line">    | <span class="literal">[]</span> -&gt; [<span class="keyword">value</span>]</span><br><span class="line">    | hd :: tl -&gt;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">QueueNode</span>.compare <span class="keyword">value</span> hd &gt; <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">value</span> :: queue</span><br><span class="line">        <span class="keyword">else</span> hd :: push tl <span class="keyword">value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> size = <span class="keyword">function</span> _ :: tl -&gt; <span class="number">1</span> + size tl | <span class="literal">[]</span> -&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> empty = <span class="keyword">function</span> hd :: tl -&gt; <span class="literal">false</span> | <span class="literal">[]</span> -&gt; <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> newQueue : <span class="type">QueueNode</span>.t <span class="built_in">list</span> = <span class="literal">[]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>构造一个<strong>int</strong>类型的优先队列模块及测试</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="type">Int_priority_queue</span> = <span class="type">Make_priority_queue</span> (<span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">type</span> t = <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> compare a b = a - b</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push <span class="literal">[]</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> int_priority_queue_print_helper = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">()</span></span><br><span class="line">  | hd :: tl -&gt;</span><br><span class="line">      <span class="type">Printf</span>.printf <span class="string">&quot;%d &quot;</span> hd ;</span><br><span class="line">      int_priority_queue_print_helper tl</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">printf <span class="string">&quot;\n&quot;</span></span><br><span class="line">;;</span><br><span class="line">int_priority_queue_print_helper priority_queue</span><br><span class="line">;;</span><br><span class="line">printf <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- : unit = ()</span><br><span class="line">5 4 3 2 1 - : unit = ()</span><br></pre></td></tr></table></figure>

<p>非常成功，因此我们现在可以直接考虑哈夫曼树所需要用的额外函数。</p>
<p><strong>合并两棵树</strong></p>
<p>注意合并操作之后我们要把 data 字段变为空，否则我们将无法区别叶子结点和非叶子结点</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> huffmanMergeTwoTree leftTree rightTree : huffmanNode =</span><br><span class="line">  &#123; data= (<span class="type">None</span>, leftTree.count + rightTree.count)</span><br><span class="line">  ; count= leftTree.count + rightTree.count</span><br><span class="line">  ; left= <span class="type">HuffmanNode</span> leftTree</span><br><span class="line">  ; right= <span class="type">HuffmanNode</span> rightTree &#125;</span><br></pre></td></tr></table></figure>

<p><strong>新建一个叶子结点</strong></p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newHuffmanNode _data count : huffmanNode =</span><br><span class="line">  &#123;data= (<span class="type">Some</span> _data, count); count; left= <span class="type">Empty</span>; right= <span class="type">Empty</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构建一个哈夫曼优先队列</strong></p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="type">Huffman_priority_queue</span> = <span class="type">Make_priority_queue</span> (<span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">type</span> t = huffmanNode</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> compare left right = right.count - left.count</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<p><strong>创建初始状态</strong></p>
<p>即不断的通过新建结点的方式生成叶子结点并且<strong>push</strong>入优先队列中</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _huffmanQueue = <span class="built_in">ref</span> <span class="type">Huffman_priority_queue</span>.newQueue</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> buildInitialHuffmanQueue = <span class="keyword">function</span></span><br><span class="line">  | hd :: tl -&gt;</span><br><span class="line">      _huffmanQueue :=</span><br><span class="line">        <span class="type">Huffman_priority_queue</span>.push !_huffmanQueue</span><br><span class="line">          (newHuffmanNode (fst hd) (snd hd)) ;</span><br><span class="line">      buildInitialHuffmanQueue tl</span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">()</span></span><br></pre></td></tr></table></figure>

<p><strong>循环构建哈夫曼树</strong></p>
<p>因为这个操作用命令式语言的 while 循环会让思路变的比较清晰，所以这边还是选择了 while 来判断出口，或者为了 FP 的思想我们可以 match 队列的 size 来判断出口但是这样实在是有些牵强感觉，对于这种数据结构和算法而言还是 while 比较直观。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generateHuffmanTreeByPriorityQueue queue =</span><br><span class="line">  <span class="keyword">while</span> <span class="type">Huffman_priority_queue</span>.size !queue &lt;&gt; <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="type">Huffman_priority_queue</span>.top !queue <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> _ = queue := <span class="type">Huffman_priority_queue</span>.pop !queue <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="type">Huffman_priority_queue</span>.top !queue <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> _ = queue := <span class="type">Huffman_priority_queue</span>.pop !queue <span class="keyword">in</span></span><br><span class="line">    queue := <span class="type">Huffman_priority_queue</span>.push !queue (huffmanMergeTwoTree a b)</span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>根据树结构生成哈夫曼编码</strong></p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generateHuffmanCodeByTree tree =</span><br><span class="line">  <span class="keyword">let</span> code = <span class="built_in">ref</span> <span class="literal">[]</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> generateCode nowCode tree =</span><br><span class="line">    <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">    | <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">    | <span class="type">HuffmanNode</span> &#123;data; count; left; right&#125; -&gt; (</span><br><span class="line">      <span class="keyword">match</span> data <span class="keyword">with</span></span><br><span class="line">      | <span class="type">None</span>, _ -&gt;</span><br><span class="line">          generateCode (nowCode ^ <span class="string">&quot;0&quot;</span>) left ;</span><br><span class="line">          generateCode (nowCode ^ <span class="string">&quot;1&quot;</span>) right</span><br><span class="line">      | <span class="type">Some</span> _data, _ -&gt; code := (data, nowCode) :: !code ) <span class="keyword">in</span></span><br><span class="line">  generateCode <span class="string">&quot;&quot;</span> tree ; code</span><br></pre></td></tr></table></figure>

<h3 id="测试及结果"><a href="#测试及结果" class="headerlink" title="测试及结果"></a>测试及结果</h3><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testData = <span class="literal">[]</span></span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;b&#x27;</span>, <span class="number">40</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;c&#x27;</span>, <span class="number">20</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;d&#x27;</span>, <span class="number">80</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;e&#x27;</span>, <span class="number">90</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;f&#x27;</span>, <span class="number">30</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;g&#x27;</span>, <span class="number">888</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;h&#x27;</span>, <span class="number">66</span>) :: testData</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">buildInitialHuffmanQueue testData</span><br><span class="line"><span class="keyword">let</span> my_huffman_tree = generateHuffmanTreeByPriorityQueue _huffmanQueue</span><br><span class="line"><span class="keyword">let</span> treeTemp = <span class="type">HuffmanNode</span> (<span class="type">Huffman_priority_queue</span>.top !_huffmanQueue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> huffmanCode =</span><br><span class="line">  generateHuffmanCodeByTree (treeTemp)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val treeTemp : huffmanTree =</span><br><span class="line">  HuffmanNode</span><br><span class="line">   &#123;data = (None, 1314); count = 1314;</span><br><span class="line">    left =</span><br><span class="line">     HuffmanNode</span><br><span class="line">      &#123;data = (None, 426); count = 426;</span><br><span class="line">       left =</span><br><span class="line">        HuffmanNode</span><br><span class="line">         &#123;data = (None, 180); count = 180;</span><br><span class="line">          left =</span><br><span class="line">           HuffmanNode</span><br><span class="line">            &#123;data = (Some <span class="string">&#x27;e&#x27;</span>, 90); count = 90;</span><br><span class="line">             left = Empty; right = Empty&#125;;</span><br><span class="line">          right =</span><br><span class="line">           HuffmanNode</span><br><span class="line">            &#123;data = (None, 90); count = 90;</span><br><span class="line">             left =</span><br><span class="line">              HuffmanNode</span><br><span class="line">               &#123;data = (Some <span class="string">&#x27;b&#x27;</span>, 40); count = 40;</span><br><span class="line">                left = Empty; right = Empty&#125;;</span><br><span class="line">             right =</span><br><span class="line">              HuffmanNode</span><br><span class="line">               &#123;data = (None, 50); count = 50;</span><br><span class="line">                left =</span><br><span class="line">                 HuffmanNode</span><br><span class="line">                  &#123;data = (Some <span class="string">&#x27;c&#x27;</span>, 20); count = 20;</span><br><span class="line">                   left = Empty; right = Empty&#125;;</span><br><span class="line">                right =</span><br><span class="line">                 HuffmanNode</span><br><span class="line">                  &#123;data = (Some <span class="string">&#x27;f&#x27;</span>, 30); count = 30;</span><br><span class="line">                   left = Empty; right = Empty&#125;&#125;&#125;&#125;;</span><br><span class="line">       right =</span><br><span class="line">        HuffmanNode</span><br><span class="line">         &#123;data = (None, 246); count = 246;</span><br><span class="line">          left =</span><br><span class="line">           HuffmanNode</span><br><span class="line">            &#123;data = (Some <span class="string">&#x27;a&#x27;</span>, 100); count = 100;</span><br><span class="line">             left = Empty; right = Empty&#125;;</span><br><span class="line">          right =</span><br><span class="line">           HuffmanNode</span><br><span class="line">            &#123;data = (None, 146); count = 146;</span><br><span class="line">             left =</span><br><span class="line">              HuffmanNode</span><br><span class="line">               &#123;data = (Some <span class="string">&#x27;h&#x27;</span>, 66); count = 66;</span><br><span class="line">                left = Empty; right = Empty&#125;;</span><br><span class="line">             right =</span><br><span class="line">              HuffmanNode</span><br><span class="line">               &#123;data = (Some <span class="string">&#x27;d&#x27;</span>, 80); count = 80;</span><br><span class="line">                left = Empty; right = Empty&#125;&#125;&#125;&#125;;</span><br><span class="line">    right =</span><br><span class="line">     HuffmanNode</span><br><span class="line">      &#123;data = (Some <span class="string">&#x27;g&#x27;</span>, 888); count = 888;</span><br><span class="line">       left = Empty; right = Empty&#125;&#125;</span><br><span class="line">val huffmanCode :</span><br><span class="line">  ((optional_char * int) * string) list ref =</span><br><span class="line">  &#123;contents =</span><br><span class="line">    [((Some <span class="string">&#x27;g&#x27;</span>, 888), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">     ((Some <span class="string">&#x27;d&#x27;</span>, 80), <span class="string">&quot;0111&quot;</span>);</span><br><span class="line">     ((Some <span class="string">&#x27;h&#x27;</span>, 66), <span class="string">&quot;0110&quot;</span>);</span><br><span class="line">     ((Some <span class="string">&#x27;a&#x27;</span>, 100), <span class="string">&quot;010&quot;</span>);</span><br><span class="line">     ((Some <span class="string">&#x27;f&#x27;</span>, 30), <span class="string">&quot;00111&quot;</span>);</span><br><span class="line">     ((Some <span class="string">&#x27;c&#x27;</span>, 20), <span class="string">&quot;00110&quot;</span>);</span><br><span class="line">     ((Some <span class="string">&#x27;b&#x27;</span>, 40), <span class="string">&quot;0010&quot;</span>);</span><br><span class="line">     ((Some <span class="string">&#x27;e&#x27;</span>, 90), <span class="string">&quot;000&quot;</span>)]&#125;</span><br></pre></td></tr></table></figure>

<p><b style="color: green">感谢观看</b></p>
<h2 id="Reference-tools"><a href="#Reference-tools" class="headerlink" title="Reference, tools"></a>Reference, tools</h2><p><a href="https://stackoverflow.com/questions/4965335/how-to-print-binary-tree-diagram">Java tree printer By Stackoverflow</a></p>
<p><a href="https://gist.github.com/jj-issuu/8414570">Ocaml AVL Tree</a></p>
<p><a href="https://dev.realworldocaml.org/">Real World Ocaml</a></p>
<p><a href="https://csacademy.com/app/graph_editor/">Graph Editor</a></p>
<p><a href="https://stackoverflow.com/questions/15344069/deletion-in-binary-search-tree-in-ocaml">deletion in BST in ocaml By Stackoverflow</a></p>
<p>孙涵、高航等.数据结构抽象建模、实现与应用[M].北京:机械工业出版社.2020.130-140</p>
<h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h2><p>###AVL</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="type">Printf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="symbol">&#x27;a</span> tree = <span class="type">Empty</span> | <span class="type">Node</span> <span class="keyword">of</span> <span class="symbol">&#x27;a</span> * <span class="symbol">&#x27;a</span> tree * <span class="symbol">&#x27;a</span> tree</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> node =</span><br><span class="line">  <span class="type">Node</span></span><br><span class="line">    ( <span class="number">1</span></span><br><span class="line">    , <span class="type">Node</span> (<span class="number">5</span>, <span class="type">Node</span> (<span class="number">4</span>, <span class="type">Empty</span>, <span class="type">Empty</span>), <span class="type">Node</span> (<span class="number">2</span>, <span class="type">Empty</span>, <span class="type">Empty</span>))</span><br><span class="line">    , <span class="type">Node</span></span><br><span class="line">        (<span class="number">3</span>, <span class="type">Node</span> (<span class="number">10</span>, <span class="type">Empty</span>, <span class="type">Node</span> (<span class="number">17</span>, <span class="type">Empty</span>, <span class="type">Empty</span>)), <span class="type">Node</span> (<span class="number">14</span>, <span class="type">Empty</span>, <span class="type">Empty</span>))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> size = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="number">0</span></span><br><span class="line">  | <span class="type">Node</span> (_, left, right) -&gt; <span class="number">1</span> + size left + size right</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> preOrder = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) -&gt; <span class="type">Printf</span>.printf <span class="string">&quot;%d &quot;</span> v ; preOrder l ; preOrder r</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> midOrder = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) -&gt; midOrder l ; <span class="type">Printf</span>.printf <span class="string">&quot;%d &quot;</span> v ; midOrder r</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> postOrder = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) -&gt; postOrder l ; postOrder r ; <span class="type">Printf</span>.printf <span class="string">&quot;%d &quot;</span> v</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"><span class="type">Printf</span>.printf <span class="string">&quot;树的大小为%d\n&quot;</span> (size node) ;</span><br><span class="line">printf <span class="string">&quot;先序遍历\n&quot;</span> ;</span><br><span class="line">preOrder node ;</span><br><span class="line">printf <span class="string">&quot;\n中序遍历\n&quot;</span> ;</span><br><span class="line">midOrder node ;</span><br><span class="line">printf <span class="string">&quot;\n后序遍历\n&quot;</span> ;</span><br><span class="line">postOrder node</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 该函数是二叉排序树的插入函数，插入数值已存在时不产生任何动作，直接返回该结点  *)</span></span><br><span class="line"><span class="comment">(* 插入数值小于当前结点 当前数值不变，右子树不变，那么就需要把这个值插入到左子树 *)</span></span><br><span class="line"><span class="comment">(* 插入数值大于当前结点 当前数字不变，左子树不变，那么就需要把这个值插入到右子树 *)</span></span><br><span class="line"><span class="comment">(* 如果碰到了空结点，那么就代表寻找到了合适的插入位置，将其插入 *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> insert tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="type">Node</span> (<span class="keyword">value</span>, <span class="type">Empty</span>, <span class="type">Empty</span>)</span><br><span class="line">  | <span class="type">Node</span> (v, left, right) -&gt;</span><br><span class="line">      <span class="keyword">if</span> v = <span class="keyword">value</span> <span class="keyword">then</span> tree</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">value</span> &lt; v <span class="keyword">then</span> <span class="type">Node</span> (v, insert left <span class="keyword">value</span>, right)</span><br><span class="line">      <span class="keyword">else</span> <span class="type">Node</span> (v, left, insert right <span class="keyword">value</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 3-1-5-2-4-17-14-10 *)</span></span><br><span class="line"><span class="keyword">let</span> node = insert <span class="type">Empty</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">4</span></span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">17</span></span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">14</span></span><br><span class="line"><span class="keyword">let</span> node = insert node <span class="number">10</span></span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">printf <span class="string">&quot;\n二叉排序树中序遍历\n&quot;</span> ;</span><br><span class="line">midOrder node</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> query tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">false</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) -&gt; v = <span class="keyword">value</span> || query l <span class="keyword">value</span> || query r <span class="keyword">value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> printBool = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">true</span> -&gt; printf <span class="string">&quot;结果为真\n&quot;</span></span><br><span class="line">  | <span class="literal">false</span> -&gt; printf <span class="string">&quot;结果为假\n&quot;</span></span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">print_endline <span class="string">&quot;&quot;</span> ;</span><br><span class="line">printBool (query node <span class="number">10</span>) ;</span><br><span class="line"><span class="comment">(* should be true *)</span></span><br><span class="line">printBool (query node <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(* should be false *)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* Print Helper *)</span></span><br><span class="line"><span class="keyword">let</span> eq a b = a = b</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 删除二叉排序树 *)</span></span><br><span class="line"><span class="comment">(* Thanks for the reference https://codereview.stackexchange.com/questions/187716/deleting-a-node-from-binary-tree-in-ocaml *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> mostRight = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; failwith <span class="string">&quot;结点存在一些问题&quot;</span></span><br><span class="line">  | <span class="type">Node</span> (v, _, <span class="type">Empty</span>) -&gt; v</span><br><span class="line">  | <span class="type">Node</span> (_, _, r) -&gt; mostRight r</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> delete tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="type">Empty</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) <span class="keyword">when</span> v &lt; <span class="keyword">value</span> -&gt; <span class="type">Node</span> (v, l, delete r <span class="keyword">value</span>)</span><br><span class="line">  | <span class="type">Node</span> (v, l, r) <span class="keyword">when</span> v &gt; <span class="keyword">value</span> -&gt; <span class="type">Node</span> (v, delete l <span class="keyword">value</span>, r)</span><br><span class="line">  | <span class="type">Node</span> (v, <span class="type">Empty</span>, <span class="type">Empty</span>) -&gt; <span class="type">Empty</span> <span class="comment">(* 直接删除自己 对应情况1 *)</span></span><br><span class="line">  | <span class="type">Node</span> (v, <span class="type">Empty</span>, r) -&gt; r <span class="comment">(* 情况2 删除自己 连接右子树*)</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, <span class="type">Empty</span>) -&gt; l <span class="comment">(* 情况2 删除自己 连接左子树*)</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r) -&gt;</span><br><span class="line">      <span class="comment">(* 情况3，替换自己，删除原来的值 *)</span></span><br><span class="line">      <span class="keyword">let</span> newValue = mostRight l <span class="keyword">in</span></span><br><span class="line">      <span class="type">Node</span> (newValue, delete l newValue, r)</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 测试删除 *)</span></span><br><span class="line"><span class="keyword">let</span> delete2 = delete node <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> delete14 = delete node <span class="number">14</span></span><br><span class="line"><span class="keyword">let</span> delete3 = delete node <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> max x y = <span class="keyword">if</span> x &gt; y <span class="keyword">then</span> x <span class="keyword">else</span> y</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> getHeight = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="number">0</span></span><br><span class="line">  | <span class="type">Node</span> (_, l, r) -&gt; max (getHeight l) (getHeight r) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> pow base power = <span class="keyword">if</span> power = <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> base * pow base (power - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pow_tr base power =</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> _pow_tr base power sum =</span><br><span class="line">    <span class="keyword">if</span> power = <span class="number">0</span> <span class="keyword">then</span> sum <span class="keyword">else</span> _pow_tr base (power - <span class="number">1</span>) (base * sum) <span class="keyword">in</span></span><br><span class="line">  _pow_tr base power <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = getHeight node</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">printf <span class="string">&quot;树的高度 %d\n&quot;</span> h</span><br><span class="line"></span><br><span class="line"><span class="comment">(*</span></span><br><span class="line"><span class="comment">绘图规则</span></span><br><span class="line"><span class="comment">一行数字 一行辅助线</span></span><br><span class="line"><span class="comment">*)</span></span><br><span class="line"><span class="comment">(* ┌ ─ ┐ └ ┴ ┘*)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="symbol">&#x27;a</span> avlTree = <span class="type">Empty</span> | <span class="type">Node</span> <span class="keyword">of</span> <span class="symbol">&#x27;a</span> * <span class="symbol">&#x27;a</span> avlTree * <span class="symbol">&#x27;a</span> avlTree * <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> avlHeight = <span class="keyword">function</span> <span class="type">Empty</span> -&gt; <span class="number">0</span> | <span class="type">Node</span> (_, _, _, h) -&gt; h</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> makeNode <span class="keyword">value</span> leftTree rightTree =</span><br><span class="line">  <span class="type">Node</span></span><br><span class="line">    ( <span class="keyword">value</span></span><br><span class="line">    , leftTree</span><br><span class="line">    , rightTree</span><br><span class="line">    , <span class="number">1</span> + max (avlHeight leftTree) (avlHeight rightTree) )</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> find avlTreeNode <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> avlTreeNode <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">false</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r, _) -&gt; (</span><br><span class="line">    <span class="keyword">match</span> v = <span class="keyword">value</span> <span class="keyword">with</span></span><br><span class="line">    | <span class="literal">true</span> -&gt; <span class="literal">true</span></span><br><span class="line">    | <span class="literal">false</span> <span class="keyword">when</span> v &lt; <span class="keyword">value</span> -&gt; find l v</span><br><span class="line">    | <span class="literal">false</span> -&gt; find r v )</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 左旋 *)</span></span><br><span class="line"><span class="keyword">let</span> rotateLeft = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, <span class="type">Node</span> (_v, _l, _r, _), _) -&gt; makeNode _v (makeNode v l _l) _r</span><br><span class="line">  | _ -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* 右旋 *)</span></span><br><span class="line"><span class="keyword">let</span> rotateRight = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Node</span> (v, <span class="type">Node</span> (_v, _l, _r, _), r, _) -&gt; makeNode _v _l (makeNode v _r r)</span><br><span class="line">  | _ -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> insert tree <span class="keyword">value</span> =</span><br><span class="line">  <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="type">Node</span> (<span class="keyword">value</span>, <span class="type">Empty</span>, <span class="type">Empty</span>, <span class="number">1</span>)</span><br><span class="line">  | <span class="type">Node</span> (v, l, r, _) -&gt; (</span><br><span class="line">      <span class="keyword">if</span> v = <span class="keyword">value</span> <span class="keyword">then</span> tree</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">value</span> &lt; v <span class="keyword">then</span></span><br><span class="line">        <span class="comment">(* 如何判断插入之后是否需要左右旋转  我们需要插入后的树的高度 *)</span></span><br><span class="line">        <span class="keyword">match</span> insert l <span class="keyword">value</span> <span class="keyword">with</span></span><br><span class="line">        | <span class="type">Empty</span> -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br><span class="line">        | <span class="type">Node</span> (_v, _l, _r, _h) <span class="keyword">as</span> _node -&gt;</span><br><span class="line">            <span class="keyword">if</span> _h - avlHeight r &lt;= <span class="number">1</span> <span class="keyword">then</span> makeNode v _node r</span><br><span class="line">              <span class="comment">(* 直接插入这个结点不需要旋转 *)</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">let</span> _node =</span><br><span class="line">                <span class="comment">(* 根据前面的描述判断是否需要多旋转一次 *)</span></span><br><span class="line">                <span class="keyword">if</span> avlHeight _l &lt; avlHeight _r <span class="keyword">then</span> rotateLeft _node <span class="keyword">else</span> _node</span><br><span class="line">              <span class="keyword">in</span></span><br><span class="line">              rotateRight (makeNode v _node r) <span class="comment">(* L? 情况通用的右旋 *)</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">match</span> insert r <span class="keyword">value</span> <span class="keyword">with</span></span><br><span class="line">        | <span class="type">Empty</span> -&gt; failwith <span class="string">&quot;Error&quot;</span></span><br><span class="line">        | <span class="type">Node</span> (_v, _l, _r, _h) <span class="keyword">as</span> _node -&gt;</span><br><span class="line">            <span class="keyword">if</span> _h - avlHeight l &lt;= <span class="number">1</span> <span class="keyword">then</span> makeNode v l _node</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">let</span> _node =</span><br><span class="line">                <span class="keyword">if</span> avlHeight _l &gt; avlHeight _r <span class="keyword">then</span> rotateRight _node <span class="keyword">else</span> _node</span><br><span class="line">              <span class="keyword">in</span></span><br><span class="line">              rotateLeft (makeNode v l _node) )</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> avlNode = insert <span class="type">Empty</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">30</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">25</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">34</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">37</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">39</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">22</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">16</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">13</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> avlNode = insert avlNode <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> avlMidOrder = <span class="keyword">function</span></span><br><span class="line">  | <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">  | <span class="type">Node</span> (v, l, r, _) -&gt; avlMidOrder l ; printf <span class="string">&quot;%d &quot;</span> v ; avlMidOrder r</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">print_newline <span class="literal">()</span></span><br><span class="line">;;</span><br><span class="line">avlMidOrder avlNode</span><br></pre></td></tr></table></figure>

<h3 id="Huffman"><a href="#Huffman" class="headerlink" title="Huffman"></a>Huffman</h3><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="type">Printf</span></span><br><span class="line"><span class="comment">(* 一个优先队列的简单实现，需要的是参数的类型和比较函数 *)</span></span><br><span class="line"><span class="keyword">module</span> <span class="keyword">type</span> <span class="type">Comparable</span> = <span class="keyword">sig</span></span><br><span class="line">  <span class="keyword">type</span> t</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> compare : t -&gt; t -&gt; <span class="built_in">int</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> <span class="type">Make_priority_queue</span> (<span class="type">QueueNode</span> : <span class="type">Comparable</span>) = <span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">let</span> top = <span class="keyword">function</span></span><br><span class="line">    | hd :: tl -&gt; hd</span><br><span class="line">    | <span class="literal">[]</span> -&gt; failwith <span class="string">&quot;没有更多结点了 Error on getTop&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pop = <span class="keyword">function</span></span><br><span class="line">    | hd :: tl -&gt; tl</span><br><span class="line">    | <span class="literal">[]</span> -&gt; failwith <span class="string">&quot;没有更多结点了 Error on pop&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> push queue <span class="keyword">value</span> =</span><br><span class="line">    <span class="keyword">match</span> queue <span class="keyword">with</span></span><br><span class="line">    | <span class="literal">[]</span> -&gt; [<span class="keyword">value</span>]</span><br><span class="line">    | hd :: tl -&gt;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">QueueNode</span>.compare <span class="keyword">value</span> hd &gt; <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">value</span> :: queue</span><br><span class="line">        <span class="keyword">else</span> hd :: push tl <span class="keyword">value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> size = <span class="keyword">function</span> _ :: tl -&gt; <span class="number">1</span> + size tl | <span class="literal">[]</span> -&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> empty = <span class="keyword">function</span> hd :: tl -&gt; <span class="literal">false</span> | <span class="literal">[]</span> -&gt; <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> newQueue : <span class="type">QueueNode</span>.t <span class="built_in">list</span> = <span class="literal">[]</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> <span class="type">Int_priority_queue</span> = <span class="type">Make_priority_queue</span> (<span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">type</span> t = <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> compare a b = a - b</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push <span class="literal">[]</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="type">Int_priority_queue</span>.push priority_queue <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> int_priority_queue_print_helper = <span class="keyword">function</span></span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">()</span></span><br><span class="line">  | hd :: tl -&gt;</span><br><span class="line">      <span class="type">Printf</span>.printf <span class="string">&quot;%d &quot;</span> hd ;</span><br><span class="line">      int_priority_queue_print_helper tl</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">printf <span class="string">&quot;\n&quot;</span></span><br><span class="line">;;</span><br><span class="line">int_priority_queue_print_helper priority_queue</span><br><span class="line">;;</span><br><span class="line">printf <span class="string">&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> priority_queue = <span class="built_in">ref</span> priority_queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> pop_all_elements queue_ref =</span><br><span class="line">  <span class="keyword">while</span> <span class="type">Int_priority_queue</span>.empty !queue_ref <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> queue_value_head = <span class="type">Int_priority_queue</span>.top !queue_ref <span class="keyword">in</span></span><br><span class="line">    printf <span class="string">&quot;%d &quot;</span> queue_value_head ;</span><br><span class="line">    queue_ref := <span class="type">Int_priority_queue</span>.pop !queue_ref</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">pop_all_elements priority_queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> optional_char = <span class="type">Some</span> <span class="keyword">of</span> <span class="built_in">char</span> | <span class="type">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* test for Some type *)</span></span><br><span class="line"><span class="keyword">module</span> <span class="type">Some_char_priority_queue</span> = <span class="type">Make_priority_queue</span> (<span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">type</span> t = optional_char * <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> compare a b = snd b - snd a</span><br><span class="line"></span><br><span class="line">  <span class="comment">(* 出现次数多的符号放在最后merge *)</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> huffman_queue = <span class="type">Some_char_priority_queue</span>.newQueue</span><br><span class="line"><span class="keyword">let</span> huffman_queue = <span class="type">Some_char_priority_queue</span>.push huffman_queue (<span class="type">Some</span> <span class="string">&#x27;a&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">let</span> huffman_queue = <span class="type">Some_char_priority_queue</span>.push huffman_queue (<span class="type">Some</span> <span class="string">&#x27;b&#x27;</span>, <span class="number">40</span>)</span><br><span class="line"><span class="keyword">let</span> huffman_queue = <span class="type">Some_char_priority_queue</span>.push huffman_queue (<span class="type">Some</span> <span class="string">&#x27;c&#x27;</span>, <span class="number">25</span>)</span><br><span class="line"><span class="keyword">let</span> huffman_queue = <span class="type">Some_char_priority_queue</span>.push huffman_queue (<span class="type">Some</span> <span class="string">&#x27;d&#x27;</span>, <span class="number">40</span>)</span><br><span class="line"><span class="keyword">let</span> huffman_queue = <span class="type">Some_char_priority_queue</span>.push huffman_queue (<span class="type">Some</span> <span class="string">&#x27;e&#x27;</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> huffman_queue = <span class="type">Some_char_priority_queue</span>.push huffman_queue (<span class="type">Some</span> <span class="string">&#x27;f&#x27;</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(* 定义哈夫曼树 *)</span></span><br><span class="line"><span class="keyword">type</span> huffmanTree = <span class="type">Empty</span> | <span class="type">HuffmanNode</span> <span class="keyword">of</span> huffmanNode</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> huffmanNode =</span><br><span class="line">  &#123;data: optional_char * <span class="built_in">int</span>; count: <span class="built_in">int</span>; left: huffmanTree; right: huffmanTree&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> huffmanMergeTwoTree leftTree rightTree : huffmanNode =</span><br><span class="line">  &#123; data= (<span class="type">None</span>, leftTree.count + rightTree.count)</span><br><span class="line">  ; count= leftTree.count + rightTree.count</span><br><span class="line">  ; left= <span class="type">HuffmanNode</span> leftTree</span><br><span class="line">  ; right= <span class="type">HuffmanNode</span> rightTree &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newHuffmanNode _data count : huffmanNode =</span><br><span class="line">  &#123;data= (<span class="type">Some</span> _data, count); count; left= <span class="type">Empty</span>; right= <span class="type">Empty</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> <span class="type">Huffman_priority_queue</span> = <span class="type">Make_priority_queue</span> (<span class="keyword">struct</span></span><br><span class="line">  <span class="keyword">type</span> t = huffmanNode</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> compare left right = right.count - left.count</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(* dataList =&gt; char * int *)</span></span><br><span class="line"><span class="keyword">let</span> _huffmanQueue = <span class="built_in">ref</span> <span class="type">Huffman_priority_queue</span>.newQueue</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> buildInitialHuffmanQueue = <span class="keyword">function</span></span><br><span class="line">  | hd :: tl -&gt;</span><br><span class="line">      _huffmanQueue :=</span><br><span class="line">        <span class="type">Huffman_priority_queue</span>.push !_huffmanQueue</span><br><span class="line">          (newHuffmanNode (fst hd) (snd hd)) ;</span><br><span class="line">      buildInitialHuffmanQueue tl</span><br><span class="line">  | <span class="literal">[]</span> -&gt; <span class="literal">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testData = <span class="literal">[]</span></span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;b&#x27;</span>, <span class="number">40</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;c&#x27;</span>, <span class="number">20</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;d&#x27;</span>, <span class="number">80</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;e&#x27;</span>, <span class="number">90</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;f&#x27;</span>, <span class="number">30</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;g&#x27;</span>, <span class="number">888</span>) :: testData</span><br><span class="line"><span class="keyword">let</span> testData = (<span class="string">&#x27;h&#x27;</span>, <span class="number">66</span>) :: testData</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">buildInitialHuffmanQueue testData</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generateHuffmanTreeByPriorityQueue queue =</span><br><span class="line">  <span class="keyword">while</span> <span class="type">Huffman_priority_queue</span>.size !queue &lt;&gt; <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="type">Huffman_priority_queue</span>.top !queue <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> _ = queue := <span class="type">Huffman_priority_queue</span>.pop !queue <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="type">Huffman_priority_queue</span>.top !queue <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> _ = queue := <span class="type">Huffman_priority_queue</span>.pop !queue <span class="keyword">in</span></span><br><span class="line">    queue := <span class="type">Huffman_priority_queue</span>.push !queue (huffmanMergeTwoTree a b)</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my_huffman_tree = generateHuffmanTreeByPriorityQueue _huffmanQueue</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generateHuffmanCodeByTree tree =</span><br><span class="line">  <span class="keyword">let</span> code = <span class="built_in">ref</span> <span class="literal">[]</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">rec</span> generateCode nowCode tree =</span><br><span class="line">    <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">    | <span class="type">Empty</span> -&gt; <span class="literal">()</span></span><br><span class="line">    | <span class="type">HuffmanNode</span> &#123;data; count; left; right&#125; -&gt; (</span><br><span class="line">      <span class="keyword">match</span> data <span class="keyword">with</span></span><br><span class="line">      | <span class="type">None</span>, _ -&gt;</span><br><span class="line">          generateCode (nowCode ^ <span class="string">&quot;0&quot;</span>) left ;</span><br><span class="line">          generateCode (nowCode ^ <span class="string">&quot;1&quot;</span>) right</span><br><span class="line">      | <span class="type">Some</span> _data, _ -&gt; code := (data, nowCode) :: !code ) <span class="keyword">in</span></span><br><span class="line">  generateCode <span class="string">&quot;&quot;</span> tree ; code</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> treeTemp = <span class="type">HuffmanNode</span> (<span class="type">Huffman_priority_queue</span>.top !_huffmanQueue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> huffmanCode =</span><br><span class="line">  generateHuffmanCodeByTree (treeTemp)</span><br></pre></td></tr></table></figure>

<h3 id="所有函数列表-AVL"><a href="#所有函数列表-AVL" class="headerlink" title="所有函数列表(AVL)"></a>所有函数列表(AVL)</h3><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="symbol">&#x27;a</span> tree = <span class="type">Empty</span> | <span class="type">Node</span> <span class="keyword">of</span> <span class="symbol">&#x27;a</span> * <span class="symbol">&#x27;a</span> tree * <span class="symbol">&#x27;a</span> tree</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> size : <span class="symbol">&#x27;a</span> tree -&gt; <span class="built_in">int</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> preOrder : <span class="built_in">int</span> tree -&gt; <span class="built_in">unit</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> midOrder : <span class="built_in">int</span> tree -&gt; <span class="built_in">unit</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> postOrder : <span class="built_in">int</span> tree -&gt; <span class="built_in">unit</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> insert : <span class="symbol">&#x27;a</span> tree -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> tree = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> query : <span class="symbol">&#x27;a</span> tree -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="built_in">bool</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> printBool : <span class="built_in">bool</span> -&gt; <span class="built_in">unit</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> eq : <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="built_in">bool</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> mostRight : <span class="symbol">&#x27;a</span> tree -&gt; <span class="symbol">&#x27;a</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> delete : <span class="symbol">&#x27;a</span> tree -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> tree = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> max : <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> getHeight : <span class="symbol">&#x27;a</span> tree -&gt; <span class="built_in">int</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> pow : <span class="built_in">int</span> -&gt; <span class="built_in">int</span> -&gt; <span class="built_in">int</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> pow_tr : <span class="built_in">int</span> -&gt; <span class="built_in">int</span> -&gt; <span class="built_in">int</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> h : <span class="built_in">int</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="symbol">&#x27;a</span> avlTree = <span class="type">Empty</span> | <span class="type">Node</span> <span class="keyword">of</span> <span class="symbol">&#x27;a</span> * <span class="symbol">&#x27;a</span> avlTree * <span class="symbol">&#x27;a</span> avlTree * <span class="built_in">int</span></span><br><span class="line"><span class="keyword">val</span> avlHeight : <span class="symbol">&#x27;a</span> avlTree -&gt; <span class="built_in">int</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> makeNode : <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> avlTree -&gt; <span class="symbol">&#x27;a</span> avlTree -&gt; <span class="symbol">&#x27;a</span> avlTree = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> find : <span class="symbol">&#x27;a</span> avlTree -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="built_in">bool</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> rotateLeft : <span class="symbol">&#x27;a</span> avlTree -&gt; <span class="symbol">&#x27;a</span> avlTree = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> rotateRight : <span class="symbol">&#x27;a</span> avlTree -&gt; <span class="symbol">&#x27;a</span> avlTree = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> insert : <span class="symbol">&#x27;a</span> avlTree -&gt; <span class="symbol">&#x27;a</span> -&gt; <span class="symbol">&#x27;a</span> avlTree = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line"><span class="keyword">val</span> avlMidOrder : <span class="built_in">int</span> avlTree -&gt; <span class="built_in">unit</span> = &lt;<span class="keyword">fun</span>&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ocaml</category>
      </categories>
      <tags>
        <tag>ocaml</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
</search>
